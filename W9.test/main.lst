                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ISO C Compiler
                                      3 ; Version 4.4.4 #15036 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	
                                      7 	.optsdcc -mmcs51 --model-small
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _DEV_CTL_PARM_2
                                     12 	.globl _led7seg_disp_PARM_2
                                     13 	.globl _DIGIT_CODE
                                     14 	.globl _main
                                     15 	.globl _main_intial
                                     16 	.globl _sys_time_disp
                                     17 	.globl _change_mode
                                     18 	.globl _SHOW_MODE
                                     19 	.globl _DEV_CTL
                                     20 	.globl _SET_ON_OFF
                                     21 	.globl _SET_TIMER
                                     22 	.globl _YES_NO
                                     23 	.globl _CODE2NUM
                                     24 	.globl _External0_Interrupt
                                     25 	.globl _Timer0_OverFlow_Interrupt
                                     26 	.globl _IR_Reading_Initial
                                     27 	.globl _read_extracted_frame
                                     28 	.globl _new_dataframe
                                     29 	.globl _Get_BTN_MATRIX_2
                                     30 	.globl _Get_BTN_MATRIX
                                     31 	.globl _Col_Read
                                     32 	.globl _Row_Write
                                     33 	.globl _Disp8leds7seg
                                     34 	.globl _led7seg_disp
                                     35 	.globl _ds1302_initial
                                     36 	.globl _ds1302_write_time
                                     37 	.globl _ds1302_read_time
                                     38 	.globl _time_equal
                                     39 	.globl _ThreeWiresProtocol_Initial
                                     40 	.globl _single_byte_read
                                     41 	.globl _single_byte_write
                                     42 	.globl _GLOBAL_INT
                                     43 	.globl _TIMER0_CTL
                                     44 	.globl _eINT1_CTL
                                     45 	.globl _eINT0_CTL
                                     46 	.globl _delay_ms
                                     47 	.globl _DEV2
                                     48 	.globl _DEV1
                                     49 	.globl _DEV0
                                     50 	.globl _FrameExtracted_LED
                                     51 	.globl _COL3
                                     52 	.globl _COL2
                                     53 	.globl _COL1
                                     54 	.globl _COL0
                                     55 	.globl _ROW3
                                     56 	.globl _ROW2
                                     57 	.globl _ROW1
                                     58 	.globl _ROW0
                                     59 	.globl _GND2
                                     60 	.globl _GND1
                                     61 	.globl _GND0
                                     62 	.globl _IO
                                     63 	.globl _SCLK
                                     64 	.globl _CE
                                     65 	.globl _CY
                                     66 	.globl _AC
                                     67 	.globl _F0
                                     68 	.globl _RS1
                                     69 	.globl _RS0
                                     70 	.globl _OV
                                     71 	.globl _FL
                                     72 	.globl _P
                                     73 	.globl _TF2
                                     74 	.globl _EXF2
                                     75 	.globl _RCLK
                                     76 	.globl _TCLK
                                     77 	.globl _EXEN2
                                     78 	.globl _TR2
                                     79 	.globl _C_T2
                                     80 	.globl _CP_RL2
                                     81 	.globl _T2CON_7
                                     82 	.globl _T2CON_6
                                     83 	.globl _T2CON_5
                                     84 	.globl _T2CON_4
                                     85 	.globl _T2CON_3
                                     86 	.globl _T2CON_2
                                     87 	.globl _T2CON_1
                                     88 	.globl _T2CON_0
                                     89 	.globl _PT2
                                     90 	.globl _PS
                                     91 	.globl _PT1
                                     92 	.globl _PX1
                                     93 	.globl _PT0
                                     94 	.globl _PX0
                                     95 	.globl _RD
                                     96 	.globl _WR
                                     97 	.globl _T1
                                     98 	.globl _T0
                                     99 	.globl _INT1
                                    100 	.globl _INT0
                                    101 	.globl _TXD
                                    102 	.globl _RXD
                                    103 	.globl _P3_7
                                    104 	.globl _P3_6
                                    105 	.globl _P3_5
                                    106 	.globl _P3_4
                                    107 	.globl _P3_3
                                    108 	.globl _P3_2
                                    109 	.globl _P3_1
                                    110 	.globl _P3_0
                                    111 	.globl _EA
                                    112 	.globl _ET2
                                    113 	.globl _ES
                                    114 	.globl _ET1
                                    115 	.globl _EX1
                                    116 	.globl _ET0
                                    117 	.globl _EX0
                                    118 	.globl _P2_7
                                    119 	.globl _P2_6
                                    120 	.globl _P2_5
                                    121 	.globl _P2_4
                                    122 	.globl _P2_3
                                    123 	.globl _P2_2
                                    124 	.globl _P2_1
                                    125 	.globl _P2_0
                                    126 	.globl _SM0
                                    127 	.globl _SM1
                                    128 	.globl _SM2
                                    129 	.globl _REN
                                    130 	.globl _TB8
                                    131 	.globl _RB8
                                    132 	.globl _TI
                                    133 	.globl _RI
                                    134 	.globl _T2EX
                                    135 	.globl _T2
                                    136 	.globl _P1_7
                                    137 	.globl _P1_6
                                    138 	.globl _P1_5
                                    139 	.globl _P1_4
                                    140 	.globl _P1_3
                                    141 	.globl _P1_2
                                    142 	.globl _P1_1
                                    143 	.globl _P1_0
                                    144 	.globl _TF1
                                    145 	.globl _TR1
                                    146 	.globl _TF0
                                    147 	.globl _TR0
                                    148 	.globl _IE1
                                    149 	.globl _IT1
                                    150 	.globl _IE0
                                    151 	.globl _IT0
                                    152 	.globl _P0_7
                                    153 	.globl _P0_6
                                    154 	.globl _P0_5
                                    155 	.globl _P0_4
                                    156 	.globl _P0_3
                                    157 	.globl _P0_2
                                    158 	.globl _P0_1
                                    159 	.globl _P0_0
                                    160 	.globl _B
                                    161 	.globl _A
                                    162 	.globl _ACC
                                    163 	.globl _PSW
                                    164 	.globl _TH2
                                    165 	.globl _TL2
                                    166 	.globl _RCAP2H
                                    167 	.globl _RCAP2L
                                    168 	.globl _T2MOD
                                    169 	.globl _T2CON
                                    170 	.globl _IP
                                    171 	.globl _P3
                                    172 	.globl _IE
                                    173 	.globl _P2
                                    174 	.globl _SBUF
                                    175 	.globl _SCON
                                    176 	.globl _P1
                                    177 	.globl _TH1
                                    178 	.globl _TH0
                                    179 	.globl _TL1
                                    180 	.globl _TL0
                                    181 	.globl _TMOD
                                    182 	.globl _TCON
                                    183 	.globl _PCON
                                    184 	.globl _DPH
                                    185 	.globl _DPL
                                    186 	.globl _SP
                                    187 	.globl _P0
                                    188 	.globl _SET_ON_OFF_PARM_2
                                    189 	.globl _time_off
                                    190 	.globl _time_on
                                    191 	.globl _sys_time
                                    192 	.globl _DEV_ENABLE
                                    193 	.globl _MANUAL_MODE
                                    194 	.globl _CURRENT_MODE
                                    195 	.globl _negedge_count
                                    196 	.globl _ms_count
                                    197 	.globl _buffer
                                    198 	.globl _data_frame
                                    199 	.globl _BTN_MATRIX
                                    200 	.globl _LED
                                    201 	.globl _ds1302_write_time_PARM_2
                                    202 	.globl _ds1302_read_time_PARM_2
                                    203 	.globl _time_equal_PARM_2
                                    204 	.globl _time_equal_PARM_1
                                    205 	.globl _single_byte_write_PARM_2
                                    206 	.globl _READ_T
                                    207 	.globl _IDLE_T
                                    208 	.globl _T_PEAK
                                    209 ;--------------------------------------------------------
                                    210 ; special function registers
                                    211 ;--------------------------------------------------------
                                    212 	.area RSEG    (ABS,DATA)
      000000                        213 	.org 0x0000
                           000080   214 _P0	=	0x0080
                           000081   215 _SP	=	0x0081
                           000082   216 _DPL	=	0x0082
                           000083   217 _DPH	=	0x0083
                           000087   218 _PCON	=	0x0087
                           000088   219 _TCON	=	0x0088
                           000089   220 _TMOD	=	0x0089
                           00008A   221 _TL0	=	0x008a
                           00008B   222 _TL1	=	0x008b
                           00008C   223 _TH0	=	0x008c
                           00008D   224 _TH1	=	0x008d
                           000090   225 _P1	=	0x0090
                           000098   226 _SCON	=	0x0098
                           000099   227 _SBUF	=	0x0099
                           0000A0   228 _P2	=	0x00a0
                           0000A8   229 _IE	=	0x00a8
                           0000B0   230 _P3	=	0x00b0
                           0000B8   231 _IP	=	0x00b8
                           0000C8   232 _T2CON	=	0x00c8
                           0000C9   233 _T2MOD	=	0x00c9
                           0000CA   234 _RCAP2L	=	0x00ca
                           0000CB   235 _RCAP2H	=	0x00cb
                           0000CC   236 _TL2	=	0x00cc
                           0000CD   237 _TH2	=	0x00cd
                           0000D0   238 _PSW	=	0x00d0
                           0000E0   239 _ACC	=	0x00e0
                           0000E0   240 _A	=	0x00e0
                           0000F0   241 _B	=	0x00f0
                                    242 ;--------------------------------------------------------
                                    243 ; special function bits
                                    244 ;--------------------------------------------------------
                                    245 	.area RSEG    (ABS,DATA)
      000000                        246 	.org 0x0000
                           000080   247 _P0_0	=	0x0080
                           000081   248 _P0_1	=	0x0081
                           000082   249 _P0_2	=	0x0082
                           000083   250 _P0_3	=	0x0083
                           000084   251 _P0_4	=	0x0084
                           000085   252 _P0_5	=	0x0085
                           000086   253 _P0_6	=	0x0086
                           000087   254 _P0_7	=	0x0087
                           000088   255 _IT0	=	0x0088
                           000089   256 _IE0	=	0x0089
                           00008A   257 _IT1	=	0x008a
                           00008B   258 _IE1	=	0x008b
                           00008C   259 _TR0	=	0x008c
                           00008D   260 _TF0	=	0x008d
                           00008E   261 _TR1	=	0x008e
                           00008F   262 _TF1	=	0x008f
                           000090   263 _P1_0	=	0x0090
                           000091   264 _P1_1	=	0x0091
                           000092   265 _P1_2	=	0x0092
                           000093   266 _P1_3	=	0x0093
                           000094   267 _P1_4	=	0x0094
                           000095   268 _P1_5	=	0x0095
                           000096   269 _P1_6	=	0x0096
                           000097   270 _P1_7	=	0x0097
                           000090   271 _T2	=	0x0090
                           000091   272 _T2EX	=	0x0091
                           000098   273 _RI	=	0x0098
                           000099   274 _TI	=	0x0099
                           00009A   275 _RB8	=	0x009a
                           00009B   276 _TB8	=	0x009b
                           00009C   277 _REN	=	0x009c
                           00009D   278 _SM2	=	0x009d
                           00009E   279 _SM1	=	0x009e
                           00009F   280 _SM0	=	0x009f
                           0000A0   281 _P2_0	=	0x00a0
                           0000A1   282 _P2_1	=	0x00a1
                           0000A2   283 _P2_2	=	0x00a2
                           0000A3   284 _P2_3	=	0x00a3
                           0000A4   285 _P2_4	=	0x00a4
                           0000A5   286 _P2_5	=	0x00a5
                           0000A6   287 _P2_6	=	0x00a6
                           0000A7   288 _P2_7	=	0x00a7
                           0000A8   289 _EX0	=	0x00a8
                           0000A9   290 _ET0	=	0x00a9
                           0000AA   291 _EX1	=	0x00aa
                           0000AB   292 _ET1	=	0x00ab
                           0000AC   293 _ES	=	0x00ac
                           0000AD   294 _ET2	=	0x00ad
                           0000AF   295 _EA	=	0x00af
                           0000B0   296 _P3_0	=	0x00b0
                           0000B1   297 _P3_1	=	0x00b1
                           0000B2   298 _P3_2	=	0x00b2
                           0000B3   299 _P3_3	=	0x00b3
                           0000B4   300 _P3_4	=	0x00b4
                           0000B5   301 _P3_5	=	0x00b5
                           0000B6   302 _P3_6	=	0x00b6
                           0000B7   303 _P3_7	=	0x00b7
                           0000B0   304 _RXD	=	0x00b0
                           0000B1   305 _TXD	=	0x00b1
                           0000B2   306 _INT0	=	0x00b2
                           0000B3   307 _INT1	=	0x00b3
                           0000B4   308 _T0	=	0x00b4
                           0000B5   309 _T1	=	0x00b5
                           0000B6   310 _WR	=	0x00b6
                           0000B7   311 _RD	=	0x00b7
                           0000B8   312 _PX0	=	0x00b8
                           0000B9   313 _PT0	=	0x00b9
                           0000BA   314 _PX1	=	0x00ba
                           0000BB   315 _PT1	=	0x00bb
                           0000BC   316 _PS	=	0x00bc
                           0000BD   317 _PT2	=	0x00bd
                           0000C8   318 _T2CON_0	=	0x00c8
                           0000C9   319 _T2CON_1	=	0x00c9
                           0000CA   320 _T2CON_2	=	0x00ca
                           0000CB   321 _T2CON_3	=	0x00cb
                           0000CC   322 _T2CON_4	=	0x00cc
                           0000CD   323 _T2CON_5	=	0x00cd
                           0000CE   324 _T2CON_6	=	0x00ce
                           0000CF   325 _T2CON_7	=	0x00cf
                           0000C8   326 _CP_RL2	=	0x00c8
                           0000C9   327 _C_T2	=	0x00c9
                           0000CA   328 _TR2	=	0x00ca
                           0000CB   329 _EXEN2	=	0x00cb
                           0000CC   330 _TCLK	=	0x00cc
                           0000CD   331 _RCLK	=	0x00cd
                           0000CE   332 _EXF2	=	0x00ce
                           0000CF   333 _TF2	=	0x00cf
                           0000D0   334 _P	=	0x00d0
                           0000D1   335 _FL	=	0x00d1
                           0000D2   336 _OV	=	0x00d2
                           0000D3   337 _RS0	=	0x00d3
                           0000D4   338 _RS1	=	0x00d4
                           0000D5   339 _F0	=	0x00d5
                           0000D6   340 _AC	=	0x00d6
                           0000D7   341 _CY	=	0x00d7
                           0000B5   342 _CE	=	0x00b5
                           0000B6   343 _SCLK	=	0x00b6
                           0000B4   344 _IO	=	0x00b4
                           0000A2   345 _GND0	=	0x00a2
                           0000A3   346 _GND1	=	0x00a3
                           0000A4   347 _GND2	=	0x00a4
                           000097   348 _ROW0	=	0x0097
                           000096   349 _ROW1	=	0x0096
                           000095   350 _ROW2	=	0x0095
                           000094   351 _ROW3	=	0x0094
                           000093   352 _COL0	=	0x0093
                           000092   353 _COL1	=	0x0092
                           000091   354 _COL2	=	0x0091
                           000090   355 _COL3	=	0x0090
                           0000A0   356 _FrameExtracted_LED	=	0x00a0
                           000005   357 _DEV0	=	0x0005
                           000006   358 _DEV1	=	0x0006
                           000007   359 _DEV2	=	0x0007
                                    360 ;--------------------------------------------------------
                                    361 ; overlayable register banks
                                    362 ;--------------------------------------------------------
                                    363 	.area REG_BANK_0	(REL,OVR,DATA)
      000000                        364 	.ds 8
                                    365 ;--------------------------------------------------------
                                    366 ; overlayable bit register bank
                                    367 ;--------------------------------------------------------
                                    368 	.area BIT_BANK	(REL,OVR,DATA)
      000000                        369 bits:
      000000                        370 	.ds 1
                           008000   371 	b0 = bits[0]
                           008100   372 	b1 = bits[1]
                           008200   373 	b2 = bits[2]
                           008300   374 	b3 = bits[3]
                           008400   375 	b4 = bits[4]
                           008500   376 	b5 = bits[5]
                           008600   377 	b6 = bits[6]
                           008700   378 	b7 = bits[7]
                                    379 ;--------------------------------------------------------
                                    380 ; internal ram data
                                    381 ;--------------------------------------------------------
                                    382 	.area DSEG    (DATA)
      000000                        383 _T_PEAK::
      000000                        384 	.ds 1
      000001                        385 _IDLE_T::
      000001                        386 	.ds 1
      000002                        387 _READ_T::
      000002                        388 	.ds 1
      000003                        389 _single_byte_write_PARM_2:
      000003                        390 	.ds 1
      000004                        391 _time_equal_PARM_1:
      000004                        392 	.ds 7
      00000B                        393 _time_equal_PARM_2:
      00000B                        394 	.ds 7
      000012                        395 _ds1302_read_time_PARM_2:
      000012                        396 	.ds 1
      000013                        397 _ds1302_read_time_time_10000_37:
      000013                        398 	.ds 3
      000016                        399 _ds1302_read_time_AM_PM_10000_38:
      000016                        400 	.ds 1
      000017                        401 _ds1302_write_time_PARM_2:
      000017                        402 	.ds 1
      000018                        403 _LED::
      000018                        404 	.ds 8
      000020                        405 _BTN_MATRIX::
      000020                        406 	.ds 2
      000022                        407 _data_frame::
      000022                        408 	.ds 2
      000024                        409 _buffer::
      000024                        410 	.ds 2
      000026                        411 _ms_count::
      000026                        412 	.ds 1
      000027                        413 _negedge_count::
      000027                        414 	.ds 1
      000028                        415 _CURRENT_MODE::
      000028                        416 	.ds 1
      000029                        417 _MANUAL_MODE::
      000029                        418 	.ds 1
      00002A                        419 _DEV_ENABLE::
      00002A                        420 	.ds 1
      00002B                        421 _sys_time::
      00002B                        422 	.ds 7
      000032                        423 _time_on::
      000032                        424 	.ds 7
      000039                        425 _time_off::
      000039                        426 	.ds 7
      000040                        427 _SET_TIMER_t_10000_99:
      000040                        428 	.ds 3
      000043                        429 _SET_TIMER_tmp_10000_100:
      000043                        430 	.ds 7
      00004A                        431 _SET_ON_OFF_PARM_2:
      00004A                        432 	.ds 1
      00004B                        433 _SET_ON_OFF_val_10000_104:
      00004B                        434 	.ds 3
      00004E                        435 _SET_ON_OFF_sloc0_1_0:
      00004E                        436 	.ds 2
      000050                        437 _change_mode_STATE_10000_115:
      000050                        438 	.ds 1
                                    439 ;--------------------------------------------------------
                                    440 ; overlayable items in internal ram
                                    441 ;--------------------------------------------------------
                                    442 	.area	OSEG    (OVR,DATA)
                                    443 	.area	OSEG    (OVR,DATA)
                                    444 	.area	OSEG    (OVR,DATA)
                                    445 	.area	OSEG    (OVR,DATA)
                                    446 	.area	OSEG    (OVR,DATA)
                                    447 	.area	OSEG    (OVR,DATA)
      000000                        448 _led7seg_disp_PARM_2:
      000000                        449 	.ds 1
                                    450 	.area	OSEG    (OVR,DATA)
                                    451 	.area	OSEG    (OVR,DATA)
                                    452 	.area	OSEG    (OVR,DATA)
                                    453 	.area	OSEG    (OVR,DATA)
                                    454 	.area	OSEG    (OVR,DATA)
      000000                        455 _DEV_CTL_PARM_2:
      000000                        456 	.ds 1
                                    457 ;--------------------------------------------------------
                                    458 ; Stack segment in internal ram
                                    459 ;--------------------------------------------------------
                                    460 	.area SSEG
      000000                        461 __start__stack:
      000000                        462 	.ds	1
                                    463 
                                    464 ;--------------------------------------------------------
                                    465 ; indirectly addressable internal ram data
                                    466 ;--------------------------------------------------------
                                    467 	.area ISEG    (DATA)
                                    468 ;--------------------------------------------------------
                                    469 ; absolute internal ram data
                                    470 ;--------------------------------------------------------
                                    471 	.area IABS    (ABS,DATA)
                                    472 	.area IABS    (ABS,DATA)
                                    473 ;--------------------------------------------------------
                                    474 ; bit data
                                    475 ;--------------------------------------------------------
                                    476 	.area BSEG    (BIT)
      000000                        477 _time_equal_sloc0_1_0:
      000000                        478 	.ds 1
                                    479 ;--------------------------------------------------------
                                    480 ; paged external ram data
                                    481 ;--------------------------------------------------------
                                    482 	.area PSEG    (PAG,XDATA)
                                    483 ;--------------------------------------------------------
                                    484 ; uninitialized external ram data
                                    485 ;--------------------------------------------------------
                                    486 	.area XSEG    (XDATA)
                                    487 ;--------------------------------------------------------
                                    488 ; absolute external ram data
                                    489 ;--------------------------------------------------------
                                    490 	.area XABS    (ABS,XDATA)
                                    491 ;--------------------------------------------------------
                                    492 ; initialized external ram data
                                    493 ;--------------------------------------------------------
                                    494 	.area XISEG   (XDATA)
                                    495 	.area HOME    (CODE)
                                    496 	.area GSINIT0 (CODE)
                                    497 	.area GSINIT1 (CODE)
                                    498 	.area GSINIT2 (CODE)
                                    499 	.area GSINIT3 (CODE)
                                    500 	.area GSINIT4 (CODE)
                                    501 	.area GSINIT5 (CODE)
                                    502 	.area GSINIT  (CODE)
                                    503 	.area GSFINAL (CODE)
                                    504 	.area CSEG    (CODE)
                                    505 ;--------------------------------------------------------
                                    506 ; interrupt vector
                                    507 ;--------------------------------------------------------
                                    508 	.area HOME    (CODE)
      000000                        509 __interrupt_vect:
      000000 02r00r00         [24]  510 	ljmp	__sdcc_gsinit_startup
      000003 02r08rC4         [24]  511 	ljmp	_External0_Interrupt
      000006                        512 	.ds	5
      00000B 02r08r77         [24]  513 	ljmp	_Timer0_OverFlow_Interrupt
                                    514 ; restartable atomic support routines
      00000E                        515 	.ds	2
      000010                        516 sdcc_atomic_exchange_rollback_start::
      000010 00               [12]  517 	nop
      000011 00               [12]  518 	nop
      000012                        519 sdcc_atomic_exchange_pdata_impl:
      000012 E2               [24]  520 	movx	a, @r0
      000013 FB               [12]  521 	mov	r3, a
      000014 EA               [12]  522 	mov	a, r2
      000015 F2               [24]  523 	movx	@r0, a
      000016 80 2C            [24]  524 	sjmp	sdcc_atomic_exchange_exit
      000018 00               [12]  525 	nop
      000019 00               [12]  526 	nop
      00001A                        527 sdcc_atomic_exchange_xdata_impl:
      00001A E0               [24]  528 	movx	a, @dptr
      00001B FB               [12]  529 	mov	r3, a
      00001C EA               [12]  530 	mov	a, r2
      00001D F0               [24]  531 	movx	@dptr, a
      00001E 80 24            [24]  532 	sjmp	sdcc_atomic_exchange_exit
      000020                        533 sdcc_atomic_compare_exchange_idata_impl:
      000020 E6               [12]  534 	mov	a, @r0
      000021 B5 02 02         [24]  535 	cjne	a, ar2, .+#5
      000024 EB               [12]  536 	mov	a, r3
      000025 F6               [12]  537 	mov	@r0, a
      000026 22               [24]  538 	ret
      000027 00               [12]  539 	nop
      000028                        540 sdcc_atomic_compare_exchange_pdata_impl:
      000028 E2               [24]  541 	movx	a, @r0
      000029 B5 02 02         [24]  542 	cjne	a, ar2, .+#5
      00002C EB               [12]  543 	mov	a, r3
      00002D F2               [24]  544 	movx	@r0, a
      00002E 22               [24]  545 	ret
      00002F 00               [12]  546 	nop
      000030                        547 sdcc_atomic_compare_exchange_xdata_impl:
      000030 E0               [24]  548 	movx	a, @dptr
      000031 B5 02 02         [24]  549 	cjne	a, ar2, .+#5
      000034 EB               [12]  550 	mov	a, r3
      000035 F0               [24]  551 	movx	@dptr, a
      000036 22               [24]  552 	ret
      000037                        553 sdcc_atomic_exchange_rollback_end::
                                    554 
      000037                        555 sdcc_atomic_exchange_gptr_impl::
      000037 30 F6 E0         [24]  556 	jnb	b.6, sdcc_atomic_exchange_xdata_impl
      00003A A8 82            [24]  557 	mov	r0, dpl
      00003C 20 F5 D3         [24]  558 	jb	b.5, sdcc_atomic_exchange_pdata_impl
      00003F                        559 sdcc_atomic_exchange_idata_impl:
      00003F EA               [12]  560 	mov	a, r2
      000040 C6               [12]  561 	xch	a, @r0
      000041 F5 82            [12]  562 	mov	dpl, a
      000043 22               [24]  563 	ret
      000044                        564 sdcc_atomic_exchange_exit:
      000044 8B 82            [24]  565 	mov	dpl, r3
      000046 22               [24]  566 	ret
      000047                        567 sdcc_atomic_compare_exchange_gptr_impl::
      000047 30 F6 E6         [24]  568 	jnb	b.6, sdcc_atomic_compare_exchange_xdata_impl
      00004A A8 82            [24]  569 	mov	r0, dpl
      00004C 20 F5 D9         [24]  570 	jb	b.5, sdcc_atomic_compare_exchange_pdata_impl
      00004F 80 CF            [24]  571 	sjmp	sdcc_atomic_compare_exchange_idata_impl
                                    572 ;--------------------------------------------------------
                                    573 ; global & static initialisations
                                    574 ;--------------------------------------------------------
                                    575 	.area HOME    (CODE)
                                    576 	.area GSINIT  (CODE)
                                    577 	.area GSFINAL (CODE)
                                    578 	.area GSINIT  (CODE)
                                    579 	.globl __sdcc_gsinit_startup
                                    580 	.globl __sdcc_program_startup
                                    581 	.globl __start__stack
                                    582 	.globl __mcs51_genXINIT
                                    583 	.globl __mcs51_genXRAMCLEAR
                                    584 	.globl __mcs51_genRAMCLEAR
                                    585 ;	ThreeWiresProtocol.h:23: uint8 T_PEAK = 0;
      000000 75*00 00         [24]  586 	mov	_T_PEAK,#0x00
                                    587 ;	ThreeWiresProtocol.h:24: uint8 IDLE_T = 0;
      000003 75*01 00         [24]  588 	mov	_IDLE_T,#0x00
                                    589 ;	ThreeWiresProtocol.h:25: uint8 READ_T = 0;
      000006 75*02 00         [24]  590 	mov	_READ_T,#0x00
                                    591 ;	LED7Seg_OnKit.h:26: uint8 LED[8] = {0, 0, 0, 0, 0, 0, 0, 0};
      000009 75*18 00         [24]  592 	mov	_LED,#0x00
      00000C 75*19 00         [24]  593 	mov	(_LED + 0x0001),#0x00
      00000F 75*1A 00         [24]  594 	mov	(_LED + 0x0002),#0x00
      000012 75*1B 00         [24]  595 	mov	(_LED + 0x0003),#0x00
      000015 75*1C 00         [24]  596 	mov	(_LED + 0x0004),#0x00
      000018 75*1D 00         [24]  597 	mov	(_LED + 0x0005),#0x00
      00001B 75*1E 00         [24]  598 	mov	(_LED + 0x0006),#0x00
      00001E 75*1F 00         [24]  599 	mov	(_LED + 0x0007),#0x00
                                    600 ;	Matrix_Button.h:22: uint32 BTN_MATRIX = 0;
      000021 E4               [12]  601 	clr	a
      000022 F5*20            [12]  602 	mov	_BTN_MATRIX,a
      000024 F5*21            [12]  603 	mov	(_BTN_MATRIX + 1),a
                                    604 ;	IR_Reading.h:55: uint32 data_frame = 0;
      000026 F5*22            [12]  605 	mov	_data_frame,a
      000028 F5*23            [12]  606 	mov	(_data_frame + 1),a
                                    607 ;	IR_Reading.h:57: uint32 buffer = 0;
      00002A F5*24            [12]  608 	mov	_buffer,a
      00002C F5*25            [12]  609 	mov	(_buffer + 1),a
                                    610 ;	IR_Reading.h:59: uint8 ms_count = 0;
      00002E F5*26            [12]  611 	mov	_ms_count,a
                                    612 ;	IR_Reading.h:61: int8 negedge_count = 0;
      000030 F5*27            [12]  613 	mov	_negedge_count,a
                                    614 ;	main.h:21: uint8 CURRENT_MODE = DEV_0_CTL;
      000032 75*28 02         [24]  615 	mov	_CURRENT_MODE,#0x02
                                    616 ;	main.h:23: uint8 MANUAL_MODE = 0;
      000035 F5*29            [12]  617 	mov	_MANUAL_MODE,a
                                    618 ;	main.h:30: uint8 DEV_ENABLE = 0;
      000037 F5*2A            [12]  619 	mov	_DEV_ENABLE,a
                                    620 ;	main.h:32: TIME sys_time = {0, 0, 0, 0, 0, 0, 0};
      000039 F5*2B            [12]  621 	mov	_sys_time,a
      00003B F5*2C            [12]  622 	mov	(_sys_time + 0x0001),a
      00003D F5*2D            [12]  623 	mov	(_sys_time + 0x0002),a
      00003F F5*2E            [12]  624 	mov	(_sys_time + 0x0003),a
      000041 F5*2F            [12]  625 	mov	(_sys_time + 0x0004),a
      000043 F5*30            [12]  626 	mov	(_sys_time + 0x0005),a
      000045 F5*31            [12]  627 	mov	(_sys_time + 0x0006),a
                                    628 ;	main.h:33: TIME time_on = {0, 0, 0, 0, 0, 0, 0};
      000047 F5*32            [12]  629 	mov	_time_on,a
      000049 F5*33            [12]  630 	mov	(_time_on + 0x0001),a
      00004B F5*34            [12]  631 	mov	(_time_on + 0x0002),a
      00004D F5*35            [12]  632 	mov	(_time_on + 0x0003),a
      00004F F5*36            [12]  633 	mov	(_time_on + 0x0004),a
      000051 F5*37            [12]  634 	mov	(_time_on + 0x0005),a
      000053 F5*38            [12]  635 	mov	(_time_on + 0x0006),a
                                    636 ;	main.h:34: TIME time_off = {0, 0, 0, 0, 0, 0, 0};
      000055 F5*39            [12]  637 	mov	_time_off,a
      000057 F5*3A            [12]  638 	mov	(_time_off + 0x0001),a
      000059 F5*3B            [12]  639 	mov	(_time_off + 0x0002),a
      00005B F5*3C            [12]  640 	mov	(_time_off + 0x0003),a
      00005D F5*3D            [12]  641 	mov	(_time_off + 0x0004),a
      00005F F5*3E            [12]  642 	mov	(_time_off + 0x0005),a
      000061 F5*3F            [12]  643 	mov	(_time_off + 0x0006),a
                                    644 	.area GSFINAL (CODE)
      000000 02r00r51         [24]  645 	ljmp	__sdcc_program_startup
                                    646 ;--------------------------------------------------------
                                    647 ; Home
                                    648 ;--------------------------------------------------------
                                    649 	.area HOME    (CODE)
                                    650 	.area HOME    (CODE)
      000051                        651 __sdcc_program_startup:
      000051 02r0ErC7         [24]  652 	ljmp	_main
                                    653 ;	return from main will return to caller
                                    654 ;--------------------------------------------------------
                                    655 ; code
                                    656 ;--------------------------------------------------------
                                    657 	.area CSEG    (CODE)
                                    658 ;------------------------------------------------------------
                                    659 ;Allocation info for local variables in function 'delay_us'
                                    660 ;------------------------------------------------------------
                                    661 ;us            Allocated to registers r6 r7 
                                    662 ;i             Allocated to registers r4 r5 
                                    663 ;------------------------------------------------------------
                                    664 ;	Base_Lib.h:60: static void delay_us(uint32 us){
                                    665 ;	-----------------------------------------
                                    666 ;	 function delay_us
                                    667 ;	-----------------------------------------
      000000                        668 _delay_us:
                           000007   669 	ar7 = 0x07
                           000006   670 	ar6 = 0x06
                           000005   671 	ar5 = 0x05
                           000004   672 	ar4 = 0x04
                           000003   673 	ar3 = 0x03
                           000002   674 	ar2 = 0x02
                           000001   675 	ar1 = 0x01
                           000000   676 	ar0 = 0x00
      000000 AE 82            [24]  677 	mov	r6, dpl
      000002 AF 83            [24]  678 	mov	r7, dph
                                    679 ;	Base_Lib.h:62: for(i = 0; i < us; i = i + 1){
      000004 7C 00            [12]  680 	mov	r4,#0x00
      000006 7D 00            [12]  681 	mov	r5,#0x00
      000008                        682 00103$:
      000008 C3               [12]  683 	clr	c
      000009 EC               [12]  684 	mov	a,r4
      00000A 9E               [12]  685 	subb	a,r6
      00000B ED               [12]  686 	mov	a,r5
      00000C 9F               [12]  687 	subb	a,r7
      00000D 50 07            [24]  688 	jnc	00105$
      00000F 0C               [12]  689 	inc	r4
      000010 BC 00 F5         [24]  690 	cjne	r4,#0x00,00103$
      000013 0D               [12]  691 	inc	r5
      000014 80 F2            [24]  692 	sjmp	00103$
      000016                        693 00105$:
                                    694 ;	Base_Lib.h:65: }
      000016 22               [24]  695 	ret
                                    696 ;------------------------------------------------------------
                                    697 ;Allocation info for local variables in function 'delay_ms'
                                    698 ;------------------------------------------------------------
                                    699 ;ms            Allocated to registers 
                                    700 ;i             Allocated to registers r4 r5 
                                    701 ;------------------------------------------------------------
                                    702 ;	Base_Lib.h:67: void delay_ms(uint32 ms){
                                    703 ;	-----------------------------------------
                                    704 ;	 function delay_ms
                                    705 ;	-----------------------------------------
      000017                        706 _delay_ms:
      000017 85 82*00         [24]  707 	mov	__mulint_PARM_2,dpl
      00001A 85 83*01         [24]  708 	mov	(__mulint_PARM_2 + 1),dph
                                    709 ;	Base_Lib.h:69: for(i = 0; i < ms*12; i = i + 1){
      00001D 90 00 0C         [24]  710 	mov	dptr,#0x000c
      000020 12r00r00         [24]  711 	lcall	__mulint
      000023 AE 82            [24]  712 	mov	r6, dpl
      000025 AF 83            [24]  713 	mov	r7, dph
      000027 7C 00            [12]  714 	mov	r4,#0x00
      000029 7D 00            [12]  715 	mov	r5,#0x00
      00002B                        716 00103$:
      00002B C3               [12]  717 	clr	c
      00002C EC               [12]  718 	mov	a,r4
      00002D 9E               [12]  719 	subb	a,r6
      00002E ED               [12]  720 	mov	a,r5
      00002F 9F               [12]  721 	subb	a,r7
      000030 50 07            [24]  722 	jnc	00105$
      000032 0C               [12]  723 	inc	r4
      000033 BC 00 F5         [24]  724 	cjne	r4,#0x00,00103$
      000036 0D               [12]  725 	inc	r5
      000037 80 F2            [24]  726 	sjmp	00103$
      000039                        727 00105$:
                                    728 ;	Base_Lib.h:72: }
      000039 22               [24]  729 	ret
                                    730 ;------------------------------------------------------------
                                    731 ;Allocation info for local variables in function 'eINT0_CTL'
                                    732 ;------------------------------------------------------------
                                    733 ;CONFIG        Allocated to registers r7 
                                    734 ;------------------------------------------------------------
                                    735 ;	Base_Lib.h:74: void eINT0_CTL(uint8 CONFIG){
                                    736 ;	-----------------------------------------
                                    737 ;	 function eINT0_CTL
                                    738 ;	-----------------------------------------
      00003A                        739 _eINT0_CTL:
      00003A AF 82            [24]  740 	mov	r7, dpl
                                    741 ;	Base_Lib.h:75: if( CONFIG == ENABLE){
      00003C BF 01 04         [24]  742 	cjne	r7,#0x01,00102$
                                    743 ;	Base_Lib.h:76: EX0 = 1;
                                    744 ;	assignBit
      00003F D2 A8            [12]  745 	setb	_EX0
                                    746 ;	Base_Lib.h:77: IT0 = 1;
                                    747 ;	assignBit
      000041 D2 88            [12]  748 	setb	_IT0
      000043                        749 00102$:
                                    750 ;	Base_Lib.h:79: if( CONFIG == DISABLE){
      000043 EF               [12]  751 	mov	a,r7
      000044 70 04            [24]  752 	jnz	00105$
                                    753 ;	Base_Lib.h:80: EX0 = 0;
                                    754 ;	assignBit
      000046 C2 A8            [12]  755 	clr	_EX0
                                    756 ;	Base_Lib.h:81: IT0 = 0;
                                    757 ;	assignBit
      000048 C2 88            [12]  758 	clr	_IT0
      00004A                        759 00105$:
                                    760 ;	Base_Lib.h:83: }
      00004A 22               [24]  761 	ret
                                    762 ;------------------------------------------------------------
                                    763 ;Allocation info for local variables in function 'eINT1_CTL'
                                    764 ;------------------------------------------------------------
                                    765 ;CONFIG        Allocated to registers r7 
                                    766 ;------------------------------------------------------------
                                    767 ;	Base_Lib.h:85: void eINT1_CTL(uint8 CONFIG){
                                    768 ;	-----------------------------------------
                                    769 ;	 function eINT1_CTL
                                    770 ;	-----------------------------------------
      00004B                        771 _eINT1_CTL:
      00004B AF 82            [24]  772 	mov	r7, dpl
                                    773 ;	Base_Lib.h:86: if( CONFIG == ENABLE){
      00004D BF 01 04         [24]  774 	cjne	r7,#0x01,00102$
                                    775 ;	Base_Lib.h:88: IT1 = 1;   
                                    776 ;	assignBit
      000050 D2 8A            [12]  777 	setb	_IT1
                                    778 ;	Base_Lib.h:90: EX1 = 1;
                                    779 ;	assignBit
      000052 D2 AA            [12]  780 	setb	_EX1
      000054                        781 00102$:
                                    782 ;	Base_Lib.h:92: if( CONFIG == DISABLE){
      000054 EF               [12]  783 	mov	a,r7
      000055 70 04            [24]  784 	jnz	00105$
                                    785 ;	Base_Lib.h:94: IT1 = 0;   
                                    786 ;	assignBit
      000057 C2 8A            [12]  787 	clr	_IT1
                                    788 ;	Base_Lib.h:96: EX1 = 0;
                                    789 ;	assignBit
      000059 C2 AA            [12]  790 	clr	_EX1
      00005B                        791 00105$:
                                    792 ;	Base_Lib.h:98: }
      00005B 22               [24]  793 	ret
                                    794 ;------------------------------------------------------------
                                    795 ;Allocation info for local variables in function 'TIMER0_CTL'
                                    796 ;------------------------------------------------------------
                                    797 ;CONFIG        Allocated to registers r7 
                                    798 ;------------------------------------------------------------
                                    799 ;	Base_Lib.h:102: void TIMER0_CTL(uint8 CONFIG){
                                    800 ;	-----------------------------------------
                                    801 ;	 function TIMER0_CTL
                                    802 ;	-----------------------------------------
      00005C                        803 _TIMER0_CTL:
                                    804 ;	Base_Lib.h:103: switch (CONFIG) {
      00005C E5 82            [12]  805 	mov	a,dpl
      00005E FF               [12]  806 	mov	r7,a
      00005F 24 FA            [12]  807 	add	a,#0xff - 0x05
      000061 40 28            [24]  808 	jc	00108$
      000063 EF               [12]  809 	mov	a,r7
      000064 2F               [12]  810 	add	a,r7
                                    811 ;	Base_Lib.h:104: case ENABLE:
      000065 90r00r69         [24]  812 	mov	dptr,#00117$
      000068 73               [24]  813 	jmp	@a+dptr
      000069                        814 00117$:
      000069 80 0D            [24]  815 	sjmp	00102$
      00006B 80 08            [24]  816 	sjmp	00101$
      00006D 80 13            [24]  817 	sjmp	00104$
      00006F 80 14            [24]  818 	sjmp	00105$
      000071 80 15            [24]  819 	sjmp	00106$
      000073 80 06            [24]  820 	sjmp	00103$
      000075                        821 00101$:
                                    822 ;	Base_Lib.h:105: ET0 = 1;            return;
                                    823 ;	assignBit
      000075 D2 A9            [12]  824 	setb	_ET0
                                    825 ;	Base_Lib.h:106: case DISABLE:
      000077 22               [24]  826 	ret
      000078                        827 00102$:
                                    828 ;	Base_Lib.h:107: ET0 = 0;            return;
                                    829 ;	assignBit
      000078 C2 A9            [12]  830 	clr	_ET0
                                    831 ;	Base_Lib.h:108: case RESET:
      00007A 22               [24]  832 	ret
      00007B                        833 00103$:
                                    834 ;	Base_Lib.h:109: TL0 = RESET_TL;
      00007B 75 8A 67         [24]  835 	mov	_TL0,#0x67
                                    836 ;	Base_Lib.h:110: TH0 = RESET_TH;     return;
      00007E 75 8C FC         [24]  837 	mov	_TH0,#0xfc
                                    838 ;	Base_Lib.h:111: case START:
      000081 22               [24]  839 	ret
      000082                        840 00104$:
                                    841 ;	Base_Lib.h:112: TR0 = 1;            return;
                                    842 ;	assignBit
      000082 D2 8C            [12]  843 	setb	_TR0
                                    844 ;	Base_Lib.h:113: case STOP:
      000084 22               [24]  845 	ret
      000085                        846 00105$:
                                    847 ;	Base_Lib.h:114: TR0 = 0;            return;
                                    848 ;	assignBit
      000085 C2 8C            [12]  849 	clr	_TR0
                                    850 ;	Base_Lib.h:115: case MODE_16BIT:
      000087 22               [24]  851 	ret
      000088                        852 00106$:
                                    853 ;	Base_Lib.h:116: TMOD = TMOD|0x01;   return;
      000088 43 89 01         [24]  854 	orl	_TMOD,#0x01
                                    855 ;	Base_Lib.h:117: }
      00008B                        856 00108$:
                                    857 ;	Base_Lib.h:118: }
      00008B 22               [24]  858 	ret
                                    859 ;------------------------------------------------------------
                                    860 ;Allocation info for local variables in function 'GLOBAL_INT'
                                    861 ;------------------------------------------------------------
                                    862 ;CONFIG        Allocated to registers r7 
                                    863 ;------------------------------------------------------------
                                    864 ;	Base_Lib.h:121: void GLOBAL_INT(uint8 CONFIG){
                                    865 ;	-----------------------------------------
                                    866 ;	 function GLOBAL_INT
                                    867 ;	-----------------------------------------
      00008C                        868 _GLOBAL_INT:
      00008C AF 82            [24]  869 	mov	r7, dpl
                                    870 ;	Base_Lib.h:122: EA=(CONFIG==ENABLE)?(1):(0);
      00008E BF 01 03         [24]  871 	cjne	r7,#0x01,00103$
      000091 EF               [12]  872 	mov	a,r7
      000092 80 01            [24]  873 	sjmp	00104$
      000094                        874 00103$:
      000094 E4               [12]  875 	clr	a
      000095                        876 00104$:
                                    877 ;	assignBit
      000095 24 FF            [12]  878 	add	a,#0xff
      000097 92 AF            [24]  879 	mov	_EA,c
                                    880 ;	Base_Lib.h:123: }
      000099 22               [24]  881 	ret
                                    882 ;------------------------------------------------------------
                                    883 ;Allocation info for local variables in function 'single_byte_write'
                                    884 ;------------------------------------------------------------
                                    885 ;byte_data     Allocated with name '_single_byte_write_PARM_2'
                                    886 ;cmd           Allocated to registers r7 
                                    887 ;nCLK          Allocated to registers r6 
                                    888 ;------------------------------------------------------------
                                    889 ;	ThreeWiresProtocol.h:30: void single_byte_write(uint8 cmd, uint8 byte_data){
                                    890 ;	-----------------------------------------
                                    891 ;	 function single_byte_write
                                    892 ;	-----------------------------------------
      00009A                        893 _single_byte_write:
      00009A AF 82            [24]  894 	mov	r7, dpl
                                    895 ;	ThreeWiresProtocol.h:33: delay_us(IDLE_T);
      00009C AD*01            [24]  896 	mov	r5,_IDLE_T
      00009E 7E 00            [12]  897 	mov	r6,#0x00
      0000A0 8D 82            [24]  898 	mov	dpl, r5
      0000A2 8E 83            [24]  899 	mov	dph, r6
      0000A4 C0 07            [24]  900 	push	ar7
      0000A6 12r00r00         [24]  901 	lcall	_delay_us
                                    902 ;	ThreeWiresProtocol.h:35: CE = HIGH; SCLK = LOW;
                                    903 ;	assignBit
      0000A9 D2 B5            [12]  904 	setb	_CE
                                    905 ;	assignBit
      0000AB C2 B6            [12]  906 	clr	_SCLK
                                    907 ;	ThreeWiresProtocol.h:37: delay_us(T_PEAK);
      0000AD AD*00            [24]  908 	mov	r5,_T_PEAK
      0000AF 7E 00            [12]  909 	mov	r6,#0x00
      0000B1 8D 82            [24]  910 	mov	dpl, r5
      0000B3 8E 83            [24]  911 	mov	dph, r6
      0000B5 12r00r00         [24]  912 	lcall	_delay_us
      0000B8 D0 07            [24]  913 	pop	ar7
                                    914 ;	ThreeWiresProtocol.h:39: for(nCLK = 1; nCLK <= 8; nCLK++){
      0000BA 7E 01            [12]  915 	mov	r6,#0x01
      0000BC                        916 00103$:
                                    917 ;	ThreeWiresProtocol.h:40: IO = (cmd&0x1);
      0000BC EF               [12]  918 	mov	a,r7
      0000BD 54 01            [12]  919 	anl	a,#0x01
                                    920 ;	assignBit
      0000BF 24 FF            [12]  921 	add	a,#0xff
      0000C1 92 B4            [24]  922 	mov	_IO,c
                                    923 ;	ThreeWiresProtocol.h:41: HL_MONO_PULSE(SCLK);
                                    924 ;	assignBit
      0000C3 D2 B6            [12]  925 	setb	_SCLK
      0000C5 AC*00            [24]  926 	mov	r4,_T_PEAK
      0000C7 7D 00            [12]  927 	mov	r5,#0x00
      0000C9 8C 82            [24]  928 	mov	dpl, r4
      0000CB 8D 83            [24]  929 	mov	dph, r5
      0000CD C0 07            [24]  930 	push	ar7
      0000CF C0 06            [24]  931 	push	ar6
      0000D1 12r00r00         [24]  932 	lcall	_delay_us
                                    933 ;	assignBit
      0000D4 C2 B6            [12]  934 	clr	_SCLK
      0000D6 AC*00            [24]  935 	mov	r4,_T_PEAK
      0000D8 7D 00            [12]  936 	mov	r5,#0x00
      0000DA 8C 82            [24]  937 	mov	dpl, r4
      0000DC 8D 83            [24]  938 	mov	dph, r5
      0000DE 12r00r00         [24]  939 	lcall	_delay_us
      0000E1 D0 06            [24]  940 	pop	ar6
      0000E3 D0 07            [24]  941 	pop	ar7
                                    942 ;	ThreeWiresProtocol.h:42: cmd = (cmd>>1);
      0000E5 EF               [12]  943 	mov	a,r7
      0000E6 C3               [12]  944 	clr	c
      0000E7 13               [12]  945 	rrc	a
      0000E8 FF               [12]  946 	mov	r7,a
                                    947 ;	ThreeWiresProtocol.h:39: for(nCLK = 1; nCLK <= 8; nCLK++){
      0000E9 0E               [12]  948 	inc	r6
      0000EA EE               [12]  949 	mov	a,r6
      0000EB 24 F7            [12]  950 	add	a,#0xff - 0x08
      0000ED 50 CD            [24]  951 	jnc	00103$
                                    952 ;	ThreeWiresProtocol.h:45: for(nCLK = 1; nCLK <= 8; nCLK++){
      0000EF 7F 01            [12]  953 	mov	r7,#0x01
      0000F1                        954 00105$:
                                    955 ;	ThreeWiresProtocol.h:46: IO = (byte_data&0x1);
      0000F1 E5*03            [12]  956 	mov	a,_single_byte_write_PARM_2
      0000F3 54 01            [12]  957 	anl	a,#0x01
                                    958 ;	assignBit
      0000F5 24 FF            [12]  959 	add	a,#0xff
      0000F7 92 B4            [24]  960 	mov	_IO,c
                                    961 ;	ThreeWiresProtocol.h:47: HL_MONO_PULSE(SCLK);
                                    962 ;	assignBit
      0000F9 D2 B6            [12]  963 	setb	_SCLK
      0000FB AD*00            [24]  964 	mov	r5,_T_PEAK
      0000FD 7E 00            [12]  965 	mov	r6,#0x00
      0000FF 8D 82            [24]  966 	mov	dpl, r5
      000101 8E 83            [24]  967 	mov	dph, r6
      000103 C0 07            [24]  968 	push	ar7
      000105 12r00r00         [24]  969 	lcall	_delay_us
                                    970 ;	assignBit
      000108 C2 B6            [12]  971 	clr	_SCLK
      00010A AD*00            [24]  972 	mov	r5,_T_PEAK
      00010C 7E 00            [12]  973 	mov	r6,#0x00
      00010E 8D 82            [24]  974 	mov	dpl, r5
      000110 8E 83            [24]  975 	mov	dph, r6
      000112 12r00r00         [24]  976 	lcall	_delay_us
      000115 D0 07            [24]  977 	pop	ar7
                                    978 ;	ThreeWiresProtocol.h:48: byte_data >>= 1;
      000117 E5*03            [12]  979 	mov	a,_single_byte_write_PARM_2
      000119 C3               [12]  980 	clr	c
      00011A 13               [12]  981 	rrc	a
      00011B F5*03            [12]  982 	mov	_single_byte_write_PARM_2,a
                                    983 ;	ThreeWiresProtocol.h:45: for(nCLK = 1; nCLK <= 8; nCLK++){
      00011D 0F               [12]  984 	inc	r7
      00011E EF               [12]  985 	mov	a,r7
      00011F 24 F7            [12]  986 	add	a,#0xff - 0x08
      000121 50 CE            [24]  987 	jnc	00105$
                                    988 ;	ThreeWiresProtocol.h:52: CE = LOW; 
                                    989 ;	assignBit
      000123 C2 B5            [12]  990 	clr	_CE
                                    991 ;	ThreeWiresProtocol.h:53: }
      000125 22               [24]  992 	ret
                                    993 ;------------------------------------------------------------
                                    994 ;Allocation info for local variables in function 'single_byte_read'
                                    995 ;------------------------------------------------------------
                                    996 ;cmd           Allocated to registers r7 
                                    997 ;nCLK          Allocated to registers r5 
                                    998 ;byte_data     Allocated to registers r6 
                                    999 ;bit_data      Allocated to registers 
                                   1000 ;------------------------------------------------------------
                                   1001 ;	ThreeWiresProtocol.h:55: uint8 single_byte_read(uint8 cmd){
                                   1002 ;	-----------------------------------------
                                   1003 ;	 function single_byte_read
                                   1004 ;	-----------------------------------------
      000126                       1005 _single_byte_read:
      000126 AF 82            [24] 1006 	mov	r7, dpl
                                   1007 ;	ThreeWiresProtocol.h:57: uint8 byte_data = 0, bit_data = 0;
      000128 7E 00            [12] 1008 	mov	r6,#0x00
                                   1009 ;	ThreeWiresProtocol.h:59: delay_us(IDLE_T);
      00012A AC*01            [24] 1010 	mov	r4,_IDLE_T
      00012C 7D 00            [12] 1011 	mov	r5,#0x00
      00012E 8C 82            [24] 1012 	mov	dpl, r4
      000130 8D 83            [24] 1013 	mov	dph, r5
      000132 C0 07            [24] 1014 	push	ar7
      000134 C0 06            [24] 1015 	push	ar6
      000136 12r00r00         [24] 1016 	lcall	_delay_us
                                   1017 ;	ThreeWiresProtocol.h:61: CE = HIGH;SCLK = LOW;
                                   1018 ;	assignBit
      000139 D2 B5            [12] 1019 	setb	_CE
                                   1020 ;	assignBit
      00013B C2 B6            [12] 1021 	clr	_SCLK
                                   1022 ;	ThreeWiresProtocol.h:62: delay_us(T_PEAK);
      00013D AC*00            [24] 1023 	mov	r4,_T_PEAK
      00013F 7D 00            [12] 1024 	mov	r5,#0x00
      000141 8C 82            [24] 1025 	mov	dpl, r4
      000143 8D 83            [24] 1026 	mov	dph, r5
      000145 12r00r00         [24] 1027 	lcall	_delay_us
      000148 D0 06            [24] 1028 	pop	ar6
      00014A D0 07            [24] 1029 	pop	ar7
                                   1030 ;	ThreeWiresProtocol.h:64: for(nCLK = 1; nCLK <= 7; nCLK++){
      00014C 7D 01            [12] 1031 	mov	r5,#0x01
      00014E                       1032 00103$:
                                   1033 ;	ThreeWiresProtocol.h:65: IO = (cmd&0x1);
      00014E EF               [12] 1034 	mov	a,r7
      00014F 54 01            [12] 1035 	anl	a,#0x01
                                   1036 ;	assignBit
      000151 24 FF            [12] 1037 	add	a,#0xff
      000153 92 B4            [24] 1038 	mov	_IO,c
                                   1039 ;	ThreeWiresProtocol.h:66: HL_MONO_PULSE(SCLK);
                                   1040 ;	assignBit
      000155 D2 B6            [12] 1041 	setb	_SCLK
      000157 AB*00            [24] 1042 	mov	r3,_T_PEAK
      000159 7C 00            [12] 1043 	mov	r4,#0x00
      00015B 8B 82            [24] 1044 	mov	dpl, r3
      00015D 8C 83            [24] 1045 	mov	dph, r4
      00015F C0 07            [24] 1046 	push	ar7
      000161 C0 06            [24] 1047 	push	ar6
      000163 C0 05            [24] 1048 	push	ar5
      000165 12r00r00         [24] 1049 	lcall	_delay_us
                                   1050 ;	assignBit
      000168 C2 B6            [12] 1051 	clr	_SCLK
      00016A AB*00            [24] 1052 	mov	r3,_T_PEAK
      00016C 7C 00            [12] 1053 	mov	r4,#0x00
      00016E 8B 82            [24] 1054 	mov	dpl, r3
      000170 8C 83            [24] 1055 	mov	dph, r4
      000172 12r00r00         [24] 1056 	lcall	_delay_us
      000175 D0 05            [24] 1057 	pop	ar5
      000177 D0 06            [24] 1058 	pop	ar6
      000179 D0 07            [24] 1059 	pop	ar7
                                   1060 ;	ThreeWiresProtocol.h:67: cmd = (cmd>>1);
      00017B EF               [12] 1061 	mov	a,r7
      00017C C3               [12] 1062 	clr	c
      00017D 13               [12] 1063 	rrc	a
      00017E FF               [12] 1064 	mov	r7,a
                                   1065 ;	ThreeWiresProtocol.h:64: for(nCLK = 1; nCLK <= 7; nCLK++){
      00017F 0D               [12] 1066 	inc	r5
      000180 ED               [12] 1067 	mov	a,r5
      000181 24 F8            [12] 1068 	add	a,#0xff - 0x07
      000183 50 C9            [24] 1069 	jnc	00103$
                                   1070 ;	ThreeWiresProtocol.h:70: IO = (cmd&0x1);
      000185 EF               [12] 1071 	mov	a,r7
      000186 54 01            [12] 1072 	anl	a,#0x01
                                   1073 ;	assignBit
      000188 24 FF            [12] 1074 	add	a,#0xff
      00018A 92 B4            [24] 1075 	mov	_IO,c
                                   1076 ;	ThreeWiresProtocol.h:71: SCLK = HIGH; delay_us(T_PEAK);
                                   1077 ;	assignBit
      00018C D2 B6            [12] 1078 	setb	_SCLK
      00018E AD*00            [24] 1079 	mov	r5,_T_PEAK
      000190 7F 00            [12] 1080 	mov	r7,#0x00
      000192 8D 82            [24] 1081 	mov	dpl, r5
      000194 8F 83            [24] 1082 	mov	dph, r7
      000196 C0 06            [24] 1083 	push	ar6
      000198 12r00r00         [24] 1084 	lcall	_delay_us
      00019B D0 06            [24] 1085 	pop	ar6
                                   1086 ;	ThreeWiresProtocol.h:73: for(nCLK = 0; nCLK <= 7; nCLK++){
      00019D 7F 00            [12] 1087 	mov	r7,#0x00
      00019F                       1088 00105$:
                                   1089 ;	ThreeWiresProtocol.h:74: SCLK = LOW;  delay_us(READ_T);
                                   1090 ;	assignBit
      00019F C2 B6            [12] 1091 	clr	_SCLK
      0001A1 AC*02            [24] 1092 	mov	r4,_READ_T
      0001A3 7D 00            [12] 1093 	mov	r5,#0x00
      0001A5 8C 82            [24] 1094 	mov	dpl, r4
      0001A7 8D 83            [24] 1095 	mov	dph, r5
      0001A9 C0 07            [24] 1096 	push	ar7
      0001AB C0 06            [24] 1097 	push	ar6
      0001AD 12r00r00         [24] 1098 	lcall	_delay_us
      0001B0 D0 06            [24] 1099 	pop	ar6
      0001B2 D0 07            [24] 1100 	pop	ar7
                                   1101 ;	ThreeWiresProtocol.h:75: bit_data = IO;
      0001B4 A2 B4            [12] 1102 	mov	c,_IO
      0001B6 E4               [12] 1103 	clr	a
      0001B7 33               [12] 1104 	rlc	a
      0001B8 FD               [12] 1105 	mov	r5,a
                                   1106 ;	ThreeWiresProtocol.h:76: byte_data = byte_data|((bit_data&0x1)<<nCLK);
      0001B9 74 01            [12] 1107 	mov	a,#0x01
      0001BB 5D               [12] 1108 	anl	a,r5
      0001BC 8F F0            [24] 1109 	mov	b,r7
      0001BE 05 F0            [12] 1110 	inc	b
      0001C0 80 02            [24] 1111 	sjmp	00137$
      0001C2                       1112 00136$:
      0001C2 25 E0            [12] 1113 	add	a,acc
      0001C4                       1114 00137$:
      0001C4 D5 F0 FB         [24] 1115 	djnz	b,00136$
      0001C7 42 06            [12] 1116 	orl	ar6,a
                                   1117 ;	ThreeWiresProtocol.h:77: delay_us(T_PEAK-READ_T);
      0001C9 AC*00            [24] 1118 	mov	r4,_T_PEAK
      0001CB 7D 00            [12] 1119 	mov	r5,#0x00
      0001CD AA*02            [24] 1120 	mov	r2,_READ_T
      0001CF 7B 00            [12] 1121 	mov	r3,#0x00
      0001D1 EC               [12] 1122 	mov	a,r4
      0001D2 C3               [12] 1123 	clr	c
      0001D3 9A               [12] 1124 	subb	a,r2
      0001D4 F5 82            [12] 1125 	mov	dpl,a
      0001D6 ED               [12] 1126 	mov	a,r5
      0001D7 9B               [12] 1127 	subb	a,r3
      0001D8 F5 83            [12] 1128 	mov	dph,a
      0001DA C0 07            [24] 1129 	push	ar7
      0001DC C0 06            [24] 1130 	push	ar6
      0001DE 12r00r00         [24] 1131 	lcall	_delay_us
                                   1132 ;	ThreeWiresProtocol.h:78: SCLK = HIGH; delay_us(T_PEAK);
                                   1133 ;	assignBit
      0001E1 D2 B6            [12] 1134 	setb	_SCLK
      0001E3 AC*00            [24] 1135 	mov	r4,_T_PEAK
      0001E5 7D 00            [12] 1136 	mov	r5,#0x00
      0001E7 8C 82            [24] 1137 	mov	dpl, r4
      0001E9 8D 83            [24] 1138 	mov	dph, r5
      0001EB 12r00r00         [24] 1139 	lcall	_delay_us
      0001EE D0 06            [24] 1140 	pop	ar6
      0001F0 D0 07            [24] 1141 	pop	ar7
                                   1142 ;	ThreeWiresProtocol.h:73: for(nCLK = 0; nCLK <= 7; nCLK++){
      0001F2 0F               [12] 1143 	inc	r7
      0001F3 EF               [12] 1144 	mov	a,r7
      0001F4 24 F8            [12] 1145 	add	a,#0xff - 0x07
      0001F6 50 A7            [24] 1146 	jnc	00105$
                                   1147 ;	ThreeWiresProtocol.h:82: CE = LOW; 
                                   1148 ;	assignBit
      0001F8 C2 B5            [12] 1149 	clr	_CE
                                   1150 ;	ThreeWiresProtocol.h:83: return byte_data;
      0001FA 8E 82            [24] 1151 	mov	dpl, r6
                                   1152 ;	ThreeWiresProtocol.h:84: }
      0001FC 22               [24] 1153 	ret
                                   1154 ;------------------------------------------------------------
                                   1155 ;Allocation info for local variables in function 'ThreeWiresProtocol_Initial'
                                   1156 ;------------------------------------------------------------
                                   1157 ;	ThreeWiresProtocol.h:86: void ThreeWiresProtocol_Initial(){
                                   1158 ;	-----------------------------------------
                                   1159 ;	 function ThreeWiresProtocol_Initial
                                   1160 ;	-----------------------------------------
      0001FD                       1161 _ThreeWiresProtocol_Initial:
                                   1162 ;	ThreeWiresProtocol.h:87: IO = LOW;
                                   1163 ;	assignBit
      0001FD C2 B4            [12] 1164 	clr	_IO
                                   1165 ;	ThreeWiresProtocol.h:88: SCLK = LOW;
                                   1166 ;	assignBit
      0001FF C2 B6            [12] 1167 	clr	_SCLK
                                   1168 ;	ThreeWiresProtocol.h:89: CE = LOW;
                                   1169 ;	assignBit
      000201 C2 B5            [12] 1170 	clr	_CE
                                   1171 ;	ThreeWiresProtocol.h:90: }
      000203 22               [24] 1172 	ret
                                   1173 ;------------------------------------------------------------
                                   1174 ;Allocation info for local variables in function 'time_equal'
                                   1175 ;------------------------------------------------------------
                                   1176 ;A             Allocated with name '_time_equal_PARM_1'
                                   1177 ;B             Allocated with name '_time_equal_PARM_2'
                                   1178 ;MASK          Allocated to registers 
                                   1179 ;------------------------------------------------------------
                                   1180 ;	DS1302.h:38: uint8 time_equal(TIME A, TIME B, uint32 MASK){
                                   1181 ;	-----------------------------------------
                                   1182 ;	 function time_equal
                                   1183 ;	-----------------------------------------
      000204                       1184 _time_equal:
                                   1185 ;	DS1302.h:39: return (A.MINUTE == B.MINUTE) && (A.HOUR == B.HOUR);
      000204 E5*10            [12] 1186 	mov	a,(_time_equal_PARM_2 + 0x0005)
      000206 B5*09 07         [24] 1187 	cjne	a,(_time_equal_PARM_1 + 0x0005),00103$
      000209 E5*0F            [12] 1188 	mov	a,(_time_equal_PARM_2 + 0x0004)
      00020B B5*08 02         [24] 1189 	cjne	a,(_time_equal_PARM_1 + 0x0004),00114$
      00020E 80 04            [24] 1190 	sjmp	00104$
      000210                       1191 00114$:
      000210                       1192 00103$:
                                   1193 ;	assignBit
      000210 C2*00            [12] 1194 	clr	_time_equal_sloc0_1_0
      000212 80 02            [24] 1195 	sjmp	00105$
      000214                       1196 00104$:
                                   1197 ;	assignBit
      000214 D2*00            [12] 1198 	setb	_time_equal_sloc0_1_0
      000216                       1199 00105$:
      000216 A2*00            [12] 1200 	mov	c,_time_equal_sloc0_1_0
      000218 E4               [12] 1201 	clr	a
      000219 33               [12] 1202 	rlc	a
      00021A F5 82            [12] 1203 	mov	dpl,a
                                   1204 ;	DS1302.h:51: }
      00021C 22               [24] 1205 	ret
                                   1206 ;------------------------------------------------------------
                                   1207 ;Allocation info for local variables in function 'ds1302_read_time'
                                   1208 ;------------------------------------------------------------
                                   1209 ;SEL           Allocated with name '_ds1302_read_time_PARM_2'
                                   1210 ;time          Allocated with name '_ds1302_read_time_time_10000_37'
                                   1211 ;x10           Allocated to registers r5 
                                   1212 ;x1            Allocated to registers r7 
                                   1213 ;byte_data     Allocated to registers r7 
                                   1214 ;AM_PM         Allocated with name '_ds1302_read_time_AM_PM_10000_38'
                                   1215 ;x10           Allocated to registers r5 
                                   1216 ;x1            Allocated to registers r7 
                                   1217 ;------------------------------------------------------------
                                   1218 ;	DS1302.h:61: void ds1302_read_time(TIME* time, uint8 SEL){
                                   1219 ;	-----------------------------------------
                                   1220 ;	 function ds1302_read_time
                                   1221 ;	-----------------------------------------
      00021D                       1222 _ds1302_read_time:
      00021D 85 82*13         [24] 1223 	mov	_ds1302_read_time_time_10000_37,dpl
      000220 85 83*14         [24] 1224 	mov	(_ds1302_read_time_time_10000_37 + 1),dph
      000223 85 F0*15         [24] 1225 	mov	(_ds1302_read_time_time_10000_37 + 2),b
                                   1226 ;	DS1302.h:64: if(SEL&0x1){
      000226 E5*12            [12] 1227 	mov	a,_ds1302_read_time_PARM_2
      000228 FC               [12] 1228 	mov	r4,a
      000229 30 E0 4A         [24] 1229 	jnb	acc.0,00102$
                                   1230 ;	DS1302.h:65: ds1302_unlock_reg();
      00022C 75*03 00         [24] 1231 	mov	_single_byte_write_PARM_2,#0x00
      00022F 75 82 8E         [24] 1232 	mov	dpl, #0x8e
      000232 C0 04            [24] 1233 	push	ar4
      000234 12r00r9A         [24] 1234 	lcall	_single_byte_write
                                   1235 ;	DS1302.h:66: byte_data = single_byte_read(0x81);
      000237 75 82 81         [24] 1236 	mov	dpl, #0x81
      00023A 12r01r26         [24] 1237 	lcall	_single_byte_read
      00023D AB 82            [24] 1238 	mov	r3, dpl
      00023F D0 04            [24] 1239 	pop	ar4
                                   1240 ;	DS1302.h:67: x10 = ((byte_data & 0x70) >> 4)*10;
      000241 8B 01            [24] 1241 	mov	ar1,r3
      000243 53 01 70         [24] 1242 	anl	ar1,#0x70
      000246 E4               [12] 1243 	clr	a
      000247 C9               [12] 1244 	xch	a,r1
      000248 C4               [12] 1245 	swap	a
      000249 54 0F            [12] 1246 	anl	a,#0x0f
      00024B 69               [12] 1247 	xrl	a,r1
      00024C C9               [12] 1248 	xch	a,r1
      00024D 54 0F            [12] 1249 	anl	a,#0x0f
      00024F C9               [12] 1250 	xch	a,r1
      000250 69               [12] 1251 	xrl	a,r1
      000251 C9               [12] 1252 	xch	a,r1
      000252 30 E3 02         [24] 1253 	jnb	acc.3,00168$
      000255 44 F0            [12] 1254 	orl	a,#0xfffffff0
      000257                       1255 00168$:
      000257 E9               [12] 1256 	mov	a,r1
      000258 75 F0 0A         [24] 1257 	mov	b,#0x0a
      00025B A4               [48] 1258 	mul	ab
      00025C F9               [12] 1259 	mov	r1,a
                                   1260 ;	DS1302.h:68: x1  = (byte_data & 0x0F);
      00025D 53 03 0F         [24] 1261 	anl	ar3,#0x0f
                                   1262 ;	DS1302.h:69: time->SECOND = x1 + x10;
      000260 74 06            [12] 1263 	mov	a,#0x06
      000262 25*13            [12] 1264 	add	a, _ds1302_read_time_time_10000_37
      000264 F8               [12] 1265 	mov	r0,a
      000265 E4               [12] 1266 	clr	a
      000266 35*14            [12] 1267 	addc	a, (_ds1302_read_time_time_10000_37 + 1)
      000268 FA               [12] 1268 	mov	r2,a
      000269 AF*15            [24] 1269 	mov	r7,(_ds1302_read_time_time_10000_37 + 2)
      00026B E9               [12] 1270 	mov	a,r1
      00026C 2B               [12] 1271 	add	a, r3
      00026D 88 82            [24] 1272 	mov	dpl,r0
      00026F 8A 83            [24] 1273 	mov	dph,r2
      000271 8F F0            [24] 1274 	mov	b,r7
      000273 12r00r00         [24] 1275 	lcall	__gptrput
      000276                       1276 00102$:
                                   1277 ;	DS1302.h:72: if(SEL&0x2){
      000276 EC               [12] 1278 	mov	a,r4
      000277 30 E1 4A         [24] 1279 	jnb	acc.1,00104$
                                   1280 ;	DS1302.h:73: ds1302_unlock_reg();
      00027A 75*03 00         [24] 1281 	mov	_single_byte_write_PARM_2,#0x00
      00027D 75 82 8E         [24] 1282 	mov	dpl, #0x8e
      000280 C0 04            [24] 1283 	push	ar4
      000282 12r00r9A         [24] 1284 	lcall	_single_byte_write
                                   1285 ;	DS1302.h:74: byte_data = single_byte_read(0x83);
      000285 75 82 83         [24] 1286 	mov	dpl, #0x83
      000288 12r01r26         [24] 1287 	lcall	_single_byte_read
      00028B AF 82            [24] 1288 	mov	r7, dpl
      00028D D0 04            [24] 1289 	pop	ar4
                                   1290 ;	DS1302.h:75: x10 = ((byte_data & 0x70) >> 4)*10;
      00028F 8F 05            [24] 1291 	mov	ar5,r7
      000291 53 05 70         [24] 1292 	anl	ar5,#0x70
      000294 E4               [12] 1293 	clr	a
      000295 CD               [12] 1294 	xch	a,r5
      000296 C4               [12] 1295 	swap	a
      000297 54 0F            [12] 1296 	anl	a,#0x0f
      000299 6D               [12] 1297 	xrl	a,r5
      00029A CD               [12] 1298 	xch	a,r5
      00029B 54 0F            [12] 1299 	anl	a,#0x0f
      00029D CD               [12] 1300 	xch	a,r5
      00029E 6D               [12] 1301 	xrl	a,r5
      00029F CD               [12] 1302 	xch	a,r5
      0002A0 30 E3 02         [24] 1303 	jnb	acc.3,00170$
      0002A3 44 F0            [12] 1304 	orl	a,#0xfffffff0
      0002A5                       1305 00170$:
      0002A5 ED               [12] 1306 	mov	a,r5
      0002A6 75 F0 0A         [24] 1307 	mov	b,#0x0a
      0002A9 A4               [48] 1308 	mul	ab
      0002AA FD               [12] 1309 	mov	r5,a
                                   1310 ;	DS1302.h:76: x1  = (byte_data & 0x0F);
      0002AB 53 07 0F         [24] 1311 	anl	ar7,#0x0f
                                   1312 ;	DS1302.h:77: time->MINUTE = x10 + x1;
      0002AE 74 05            [12] 1313 	mov	a,#0x05
      0002B0 25*13            [12] 1314 	add	a, _ds1302_read_time_time_10000_37
      0002B2 FA               [12] 1315 	mov	r2,a
      0002B3 E4               [12] 1316 	clr	a
      0002B4 35*14            [12] 1317 	addc	a, (_ds1302_read_time_time_10000_37 + 1)
      0002B6 FB               [12] 1318 	mov	r3,a
      0002B7 AE*15            [24] 1319 	mov	r6,(_ds1302_read_time_time_10000_37 + 2)
      0002B9 EF               [12] 1320 	mov	a,r7
      0002BA 2D               [12] 1321 	add	a, r5
      0002BB 8A 82            [24] 1322 	mov	dpl,r2
      0002BD 8B 83            [24] 1323 	mov	dph,r3
      0002BF 8E F0            [24] 1324 	mov	b,r6
      0002C1 12r00r00         [24] 1325 	lcall	__gptrput
      0002C4                       1326 00104$:
                                   1327 ;	DS1302.h:80: if(SEL&0x4){
      0002C4 EC               [12] 1328 	mov	a,r4
      0002C5 20 E2 03         [24] 1329 	jb	acc.2,00171$
      0002C8 02r03r7D         [24] 1330 	ljmp	00109$
      0002CB                       1331 00171$:
                                   1332 ;	DS1302.h:81: ds1302_unlock_reg();
      0002CB 75*03 00         [24] 1333 	mov	_single_byte_write_PARM_2,#0x00
      0002CE 75 82 8E         [24] 1334 	mov	dpl, #0x8e
      0002D1 C0 04            [24] 1335 	push	ar4
      0002D3 12r00r9A         [24] 1336 	lcall	_single_byte_write
                                   1337 ;	DS1302.h:82: byte_data = single_byte_read(0x85);
      0002D6 75 82 85         [24] 1338 	mov	dpl, #0x85
      0002D9 12r01r26         [24] 1339 	lcall	_single_byte_read
      0002DC AF 82            [24] 1340 	mov	r7, dpl
      0002DE D0 04            [24] 1341 	pop	ar4
                                   1342 ;	DS1302.h:83: if( (byte_data & 0x80) == HIGH){
      0002E0 8F 05            [24] 1343 	mov	ar5,r7
      0002E2 74 80            [12] 1344 	mov	a,#0x80
      0002E4 5D               [12] 1345 	anl	a,r5
      0002E5 FA               [12] 1346 	mov	r2,a
      0002E6 7B 00            [12] 1347 	mov	r3,#0x00
      0002E8 BA 01 5F         [24] 1348 	cjne	r2,#0x01,00106$
      0002EB BB 00 5C         [24] 1349 	cjne	r3,#0x00,00106$
                                   1350 ;	DS1302.h:85: x10 = ((byte_data & 0x10)>>4)*10;
      0002EE C0 04            [24] 1351 	push	ar4
      0002F0 74 10            [12] 1352 	mov	a,#0x10
      0002F2 5D               [12] 1353 	anl	a,r5
      0002F3 FA               [12] 1354 	mov	r2,a
      0002F4 E4               [12] 1355 	clr	a
      0002F5 CA               [12] 1356 	xch	a,r2
      0002F6 C4               [12] 1357 	swap	a
      0002F7 54 0F            [12] 1358 	anl	a,#0x0f
      0002F9 6A               [12] 1359 	xrl	a,r2
      0002FA CA               [12] 1360 	xch	a,r2
      0002FB 54 0F            [12] 1361 	anl	a,#0x0f
      0002FD CA               [12] 1362 	xch	a,r2
      0002FE 6A               [12] 1363 	xrl	a,r2
      0002FF CA               [12] 1364 	xch	a,r2
      000300 30 E3 02         [24] 1365 	jnb	acc.3,00174$
      000303 44 F0            [12] 1366 	orl	a,#0xfffffff0
      000305                       1367 00174$:
      000305 EA               [12] 1368 	mov	a,r2
      000306 75 F0 0A         [24] 1369 	mov	b,#0x0a
      000309 A4               [48] 1370 	mul	ab
      00030A FA               [12] 1371 	mov	r2,a
                                   1372 ;	DS1302.h:86: x1  = (byte_data & 0x0F);
      00030B 74 0F            [12] 1373 	mov	a,#0x0f
      00030D 5F               [12] 1374 	anl	a,r7
      00030E FB               [12] 1375 	mov	r3,a
                                   1376 ;	DS1302.h:87: AM_PM = (byte_data&0x20)>>5;
      00030F 74 20            [12] 1377 	mov	a,#0x20
      000311 5D               [12] 1378 	anl	a,r5
      000312 F8               [12] 1379 	mov	r0,a
      000313 E4               [12] 1380 	clr	a
      000314 03               [12] 1381 	rr	a
      000315 C8               [12] 1382 	xch	a,r0
      000316 C4               [12] 1383 	swap	a
      000317 03               [12] 1384 	rr	a
      000318 54 07            [12] 1385 	anl	a,#0x07
      00031A 68               [12] 1386 	xrl	a,r0
      00031B C8               [12] 1387 	xch	a,r0
      00031C 54 07            [12] 1388 	anl	a,#0x07
      00031E C8               [12] 1389 	xch	a,r0
      00031F 68               [12] 1390 	xrl	a,r0
      000320 C8               [12] 1391 	xch	a,r0
      000321 30 E2 02         [24] 1392 	jnb	acc.2,00175$
      000324 44 F8            [12] 1393 	orl	a,#0xfffffff8
      000326                       1394 00175$:
      000326 88*16            [24] 1395 	mov	_ds1302_read_time_AM_PM_10000_38,r0
                                   1396 ;	DS1302.h:88: time->HOUR = x10 + x1 + AM_PM * 12;
      000328 74 04            [12] 1397 	mov	a,#0x04
      00032A 25*13            [12] 1398 	add	a, _ds1302_read_time_time_10000_37
      00032C F8               [12] 1399 	mov	r0,a
      00032D E4               [12] 1400 	clr	a
      00032E 35*14            [12] 1401 	addc	a, (_ds1302_read_time_time_10000_37 + 1)
      000330 F9               [12] 1402 	mov	r1,a
      000331 AC*15            [24] 1403 	mov	r4,(_ds1302_read_time_time_10000_37 + 2)
      000333 EB               [12] 1404 	mov	a,r3
      000334 2A               [12] 1405 	add	a, r2
      000335 FA               [12] 1406 	mov	r2,a
      000336 E5*16            [12] 1407 	mov	a,_ds1302_read_time_AM_PM_10000_38
      000338 75 F0 0C         [24] 1408 	mov	b,#0x0c
      00033B A4               [48] 1409 	mul	ab
      00033C 2A               [12] 1410 	add	a,r2
      00033D 88 82            [24] 1411 	mov	dpl,r0
      00033F 89 83            [24] 1412 	mov	dph,r1
      000341 8C F0            [24] 1413 	mov	b,r4
      000343 12r00r00         [24] 1414 	lcall	__gptrput
      000346 D0 04            [24] 1415 	pop	ar4
      000348 80 33            [24] 1416 	sjmp	00109$
      00034A                       1417 00106$:
                                   1418 ;	DS1302.h:91: uint8 x10 = ((byte_data & 0x30)>>4)*10;
      00034A 53 05 30         [24] 1419 	anl	ar5,#0x30
      00034D E4               [12] 1420 	clr	a
      00034E CD               [12] 1421 	xch	a,r5
      00034F C4               [12] 1422 	swap	a
      000350 54 0F            [12] 1423 	anl	a,#0x0f
      000352 6D               [12] 1424 	xrl	a,r5
      000353 CD               [12] 1425 	xch	a,r5
      000354 54 0F            [12] 1426 	anl	a,#0x0f
      000356 CD               [12] 1427 	xch	a,r5
      000357 6D               [12] 1428 	xrl	a,r5
      000358 CD               [12] 1429 	xch	a,r5
      000359 30 E3 02         [24] 1430 	jnb	acc.3,00176$
      00035C 44 F0            [12] 1431 	orl	a,#0xfffffff0
      00035E                       1432 00176$:
      00035E ED               [12] 1433 	mov	a,r5
      00035F 75 F0 0A         [24] 1434 	mov	b,#0x0a
      000362 A4               [48] 1435 	mul	ab
      000363 FD               [12] 1436 	mov	r5,a
                                   1437 ;	DS1302.h:92: uint8 x1  = (byte_data & 0x0F);
      000364 53 07 0F         [24] 1438 	anl	ar7,#0x0f
                                   1439 ;	DS1302.h:93: time->HOUR = x10 + x1;
      000367 74 04            [12] 1440 	mov	a,#0x04
      000369 25*13            [12] 1441 	add	a, _ds1302_read_time_time_10000_37
      00036B FA               [12] 1442 	mov	r2,a
      00036C E4               [12] 1443 	clr	a
      00036D 35*14            [12] 1444 	addc	a, (_ds1302_read_time_time_10000_37 + 1)
      00036F FB               [12] 1445 	mov	r3,a
      000370 AE*15            [24] 1446 	mov	r6,(_ds1302_read_time_time_10000_37 + 2)
      000372 EF               [12] 1447 	mov	a,r7
      000373 2D               [12] 1448 	add	a, r5
      000374 8A 82            [24] 1449 	mov	dpl,r2
      000376 8B 83            [24] 1450 	mov	dph,r3
      000378 8E F0            [24] 1451 	mov	b,r6
      00037A 12r00r00         [24] 1452 	lcall	__gptrput
      00037D                       1453 00109$:
                                   1454 ;	DS1302.h:97: if(SEL&0x10){
      00037D EC               [12] 1455 	mov	a,r4
      00037E 30 E4 4A         [24] 1456 	jnb	acc.4,00111$
                                   1457 ;	DS1302.h:98: ds1302_unlock_reg();
      000381 75*03 00         [24] 1458 	mov	_single_byte_write_PARM_2,#0x00
      000384 75 82 8E         [24] 1459 	mov	dpl, #0x8e
      000387 C0 04            [24] 1460 	push	ar4
      000389 12r00r9A         [24] 1461 	lcall	_single_byte_write
                                   1462 ;	DS1302.h:99: byte_data = single_byte_read(0x87);
      00038C 75 82 87         [24] 1463 	mov	dpl, #0x87
      00038F 12r01r26         [24] 1464 	lcall	_single_byte_read
      000392 AF 82            [24] 1465 	mov	r7, dpl
      000394 D0 04            [24] 1466 	pop	ar4
                                   1467 ;	DS1302.h:100: x10 = ((byte_data&0x30)>>4)*10;
      000396 8F 05            [24] 1468 	mov	ar5,r7
      000398 53 05 30         [24] 1469 	anl	ar5,#0x30
      00039B E4               [12] 1470 	clr	a
      00039C CD               [12] 1471 	xch	a,r5
      00039D C4               [12] 1472 	swap	a
      00039E 54 0F            [12] 1473 	anl	a,#0x0f
      0003A0 6D               [12] 1474 	xrl	a,r5
      0003A1 CD               [12] 1475 	xch	a,r5
      0003A2 54 0F            [12] 1476 	anl	a,#0x0f
      0003A4 CD               [12] 1477 	xch	a,r5
      0003A5 6D               [12] 1478 	xrl	a,r5
      0003A6 CD               [12] 1479 	xch	a,r5
      0003A7 30 E3 02         [24] 1480 	jnb	acc.3,00178$
      0003AA 44 F0            [12] 1481 	orl	a,#0xfffffff0
      0003AC                       1482 00178$:
      0003AC ED               [12] 1483 	mov	a,r5
      0003AD 75 F0 0A         [24] 1484 	mov	b,#0x0a
      0003B0 A4               [48] 1485 	mul	ab
      0003B1 FD               [12] 1486 	mov	r5,a
                                   1487 ;	DS1302.h:101: x1  = (byte_data&0x0F);
      0003B2 53 07 0F         [24] 1488 	anl	ar7,#0x0f
                                   1489 ;	DS1302.h:102: time->DATE = x10 + x1;
      0003B5 74 01            [12] 1490 	mov	a,#0x01
      0003B7 25*13            [12] 1491 	add	a, _ds1302_read_time_time_10000_37
      0003B9 FA               [12] 1492 	mov	r2,a
      0003BA E4               [12] 1493 	clr	a
      0003BB 35*14            [12] 1494 	addc	a, (_ds1302_read_time_time_10000_37 + 1)
      0003BD FB               [12] 1495 	mov	r3,a
      0003BE AE*15            [24] 1496 	mov	r6,(_ds1302_read_time_time_10000_37 + 2)
      0003C0 EF               [12] 1497 	mov	a,r7
      0003C1 2D               [12] 1498 	add	a, r5
      0003C2 8A 82            [24] 1499 	mov	dpl,r2
      0003C4 8B 83            [24] 1500 	mov	dph,r3
      0003C6 8E F0            [24] 1501 	mov	b,r6
      0003C8 12r00r00         [24] 1502 	lcall	__gptrput
      0003CB                       1503 00111$:
                                   1504 ;	DS1302.h:105: if(SEL&0x20){
      0003CB EC               [12] 1505 	mov	a,r4
      0003CC 30 E5 4A         [24] 1506 	jnb	acc.5,00113$
                                   1507 ;	DS1302.h:106: ds1302_unlock_reg();
      0003CF 75*03 00         [24] 1508 	mov	_single_byte_write_PARM_2,#0x00
      0003D2 75 82 8E         [24] 1509 	mov	dpl, #0x8e
      0003D5 C0 04            [24] 1510 	push	ar4
      0003D7 12r00r9A         [24] 1511 	lcall	_single_byte_write
                                   1512 ;	DS1302.h:107: byte_data = single_byte_read(0x89);
      0003DA 75 82 89         [24] 1513 	mov	dpl, #0x89
      0003DD 12r01r26         [24] 1514 	lcall	_single_byte_read
      0003E0 AF 82            [24] 1515 	mov	r7, dpl
      0003E2 D0 04            [24] 1516 	pop	ar4
                                   1517 ;	DS1302.h:108: x10 = ((byte_data&0x10)>>4)*10;
      0003E4 8F 05            [24] 1518 	mov	ar5,r7
      0003E6 53 05 10         [24] 1519 	anl	ar5,#0x10
      0003E9 E4               [12] 1520 	clr	a
      0003EA CD               [12] 1521 	xch	a,r5
      0003EB C4               [12] 1522 	swap	a
      0003EC 54 0F            [12] 1523 	anl	a,#0x0f
      0003EE 6D               [12] 1524 	xrl	a,r5
      0003EF CD               [12] 1525 	xch	a,r5
      0003F0 54 0F            [12] 1526 	anl	a,#0x0f
      0003F2 CD               [12] 1527 	xch	a,r5
      0003F3 6D               [12] 1528 	xrl	a,r5
      0003F4 CD               [12] 1529 	xch	a,r5
      0003F5 30 E3 02         [24] 1530 	jnb	acc.3,00180$
      0003F8 44 F0            [12] 1531 	orl	a,#0xfffffff0
      0003FA                       1532 00180$:
      0003FA ED               [12] 1533 	mov	a,r5
      0003FB 75 F0 0A         [24] 1534 	mov	b,#0x0a
      0003FE A4               [48] 1535 	mul	ab
      0003FF FD               [12] 1536 	mov	r5,a
                                   1537 ;	DS1302.h:109: x1  = (byte_data&0x0F);
      000400 53 07 0F         [24] 1538 	anl	ar7,#0x0f
                                   1539 ;	DS1302.h:110: time->MONTH = x10 + x1;
      000403 74 02            [12] 1540 	mov	a,#0x02
      000405 25*13            [12] 1541 	add	a, _ds1302_read_time_time_10000_37
      000407 FA               [12] 1542 	mov	r2,a
      000408 E4               [12] 1543 	clr	a
      000409 35*14            [12] 1544 	addc	a, (_ds1302_read_time_time_10000_37 + 1)
      00040B FB               [12] 1545 	mov	r3,a
      00040C AE*15            [24] 1546 	mov	r6,(_ds1302_read_time_time_10000_37 + 2)
      00040E EF               [12] 1547 	mov	a,r7
      00040F 2D               [12] 1548 	add	a, r5
      000410 8A 82            [24] 1549 	mov	dpl,r2
      000412 8B 83            [24] 1550 	mov	dph,r3
      000414 8E F0            [24] 1551 	mov	b,r6
      000416 12r00r00         [24] 1552 	lcall	__gptrput
      000419                       1553 00113$:
                                   1554 ;	DS1302.h:113: if(SEL&0x40){
      000419 EC               [12] 1555 	mov	a,r4
      00041A 30 E6 46         [24] 1556 	jnb	acc.6,00116$
                                   1557 ;	DS1302.h:114: ds1302_unlock_reg();
      00041D 75*03 00         [24] 1558 	mov	_single_byte_write_PARM_2,#0x00
      000420 75 82 8E         [24] 1559 	mov	dpl, #0x8e
      000423 12r00r9A         [24] 1560 	lcall	_single_byte_write
                                   1561 ;	DS1302.h:115: byte_data = single_byte_read(0x87);
      000426 75 82 87         [24] 1562 	mov	dpl, #0x87
      000429 12r01r26         [24] 1563 	lcall	_single_byte_read
      00042C AF 82            [24] 1564 	mov	r7, dpl
                                   1565 ;	DS1302.h:116: x10 = ((byte_data&0xF0)>>4)*10;
      00042E 8F 05            [24] 1566 	mov	ar5,r7
      000430 53 05 F0         [24] 1567 	anl	ar5,#0xf0
      000433 E4               [12] 1568 	clr	a
      000434 CD               [12] 1569 	xch	a,r5
      000435 C4               [12] 1570 	swap	a
      000436 54 0F            [12] 1571 	anl	a,#0x0f
      000438 6D               [12] 1572 	xrl	a,r5
      000439 CD               [12] 1573 	xch	a,r5
      00043A 54 0F            [12] 1574 	anl	a,#0x0f
      00043C CD               [12] 1575 	xch	a,r5
      00043D 6D               [12] 1576 	xrl	a,r5
      00043E CD               [12] 1577 	xch	a,r5
      00043F 30 E3 02         [24] 1578 	jnb	acc.3,00182$
      000442 44 F0            [12] 1579 	orl	a,#0xfffffff0
      000444                       1580 00182$:
      000444 ED               [12] 1581 	mov	a,r5
      000445 75 F0 0A         [24] 1582 	mov	b,#0x0a
      000448 A4               [48] 1583 	mul	ab
      000449 FD               [12] 1584 	mov	r5,a
                                   1585 ;	DS1302.h:117: x1  = (byte_data&0x0F);
      00044A 53 07 0F         [24] 1586 	anl	ar7,#0x0f
                                   1587 ;	DS1302.h:118: time->YEAR = x10 + x1;
      00044D 74 03            [12] 1588 	mov	a,#0x03
      00044F 25*13            [12] 1589 	add	a, _ds1302_read_time_time_10000_37
      000451 FB               [12] 1590 	mov	r3,a
      000452 E4               [12] 1591 	clr	a
      000453 35*14            [12] 1592 	addc	a, (_ds1302_read_time_time_10000_37 + 1)
      000455 FC               [12] 1593 	mov	r4,a
      000456 AE*15            [24] 1594 	mov	r6,(_ds1302_read_time_time_10000_37 + 2)
      000458 EF               [12] 1595 	mov	a,r7
      000459 2D               [12] 1596 	add	a, r5
      00045A 8B 82            [24] 1597 	mov	dpl,r3
      00045C 8C 83            [24] 1598 	mov	dph,r4
      00045E 8E F0            [24] 1599 	mov	b,r6
                                   1600 ;	DS1302.h:120: }
      000460 02r00r00         [24] 1601 	ljmp	__gptrput
      000463                       1602 00116$:
      000463 22               [24] 1603 	ret
                                   1604 ;------------------------------------------------------------
                                   1605 ;Allocation info for local variables in function 'ds1302_write_time'
                                   1606 ;------------------------------------------------------------
                                   1607 ;SEL           Allocated with name '_ds1302_write_time_PARM_2'
                                   1608 ;time          Allocated to registers r5 r6 r7 
                                   1609 ;x10           Allocated to registers r3 
                                   1610 ;x1            Allocated to registers r1 
                                   1611 ;byte_data     Allocated to registers r1 
                                   1612 ;------------------------------------------------------------
                                   1613 ;	DS1302.h:122: void ds1302_write_time(TIME* const time, uint8 SEL){
                                   1614 ;	-----------------------------------------
                                   1615 ;	 function ds1302_write_time
                                   1616 ;	-----------------------------------------
      000464                       1617 _ds1302_write_time:
      000464 AD 82            [24] 1618 	mov	r5, dpl
      000466 AE 83            [24] 1619 	mov	r6, dph
      000468 AF F0            [24] 1620 	mov	r7, b
                                   1621 ;	DS1302.h:125: if(SEL&0x1){
      00046A E5*17            [12] 1622 	mov	a,_ds1302_write_time_PARM_2
      00046C FC               [12] 1623 	mov	r4,a
      00046D 30 E0 4F         [24] 1624 	jnb	acc.0,00102$
                                   1625 ;	DS1302.h:126: x10 = (((*time).SECOND)/10)%10;
      000470 74 06            [12] 1626 	mov	a,#0x06
      000472 2D               [12] 1627 	add	a, r5
      000473 F9               [12] 1628 	mov	r1,a
      000474 E4               [12] 1629 	clr	a
      000475 3E               [12] 1630 	addc	a, r6
      000476 FA               [12] 1631 	mov	r2,a
      000477 8F 03            [24] 1632 	mov	ar3,r7
      000479 89 82            [24] 1633 	mov	dpl,r1
      00047B 8A 83            [24] 1634 	mov	dph,r2
      00047D 8B F0            [24] 1635 	mov	b,r3
      00047F 12r00r00         [24] 1636 	lcall	__gptrget
      000482 F9               [12] 1637 	mov	r1,a
      000483 75 F0 0A         [24] 1638 	mov	b,#0x0a
      000486 84               [48] 1639 	div	ab
      000487 75 F0 0A         [24] 1640 	mov	b,#0x0a
      00048A 84               [48] 1641 	div	ab
      00048B AB F0            [24] 1642 	mov	r3,b
                                   1643 ;	DS1302.h:127: x1  = ((*time).SECOND)%10;
      00048D 75 F0 0A         [24] 1644 	mov	b,#0x0a
      000490 E9               [12] 1645 	mov	a,r1
      000491 84               [48] 1646 	div	ab
      000492 A9 F0            [24] 1647 	mov	r1,b
                                   1648 ;	DS1302.h:128: byte_data = (x10<<4) + x1;
      000494 EB               [12] 1649 	mov	a,r3
      000495 C4               [12] 1650 	swap	a
      000496 54 F0            [12] 1651 	anl	a,#0xf0
      000498 29               [12] 1652 	add	a,r1
      000499 FB               [12] 1653 	mov	r3,a
                                   1654 ;	DS1302.h:129: ds1302_unlock_reg();
      00049A 75*03 00         [24] 1655 	mov	_single_byte_write_PARM_2,#0x00
      00049D 75 82 8E         [24] 1656 	mov	dpl, #0x8e
      0004A0 C0 07            [24] 1657 	push	ar7
      0004A2 C0 06            [24] 1658 	push	ar6
      0004A4 C0 05            [24] 1659 	push	ar5
      0004A6 C0 04            [24] 1660 	push	ar4
      0004A8 C0 03            [24] 1661 	push	ar3
      0004AA 12r00r9A         [24] 1662 	lcall	_single_byte_write
      0004AD D0 03            [24] 1663 	pop	ar3
                                   1664 ;	DS1302.h:130: single_byte_write(0x80, byte_data);
      0004AF 8B*03            [24] 1665 	mov	_single_byte_write_PARM_2,r3
      0004B1 75 82 80         [24] 1666 	mov	dpl, #0x80
      0004B4 12r00r9A         [24] 1667 	lcall	_single_byte_write
      0004B7 D0 04            [24] 1668 	pop	ar4
      0004B9 D0 05            [24] 1669 	pop	ar5
      0004BB D0 06            [24] 1670 	pop	ar6
      0004BD D0 07            [24] 1671 	pop	ar7
      0004BF                       1672 00102$:
                                   1673 ;	DS1302.h:133: if(SEL&0x2){
      0004BF EC               [12] 1674 	mov	a,r4
      0004C0 30 E1 4F         [24] 1675 	jnb	acc.1,00104$
                                   1676 ;	DS1302.h:134: x10 = ((time->MINUTE)/10)%10;
      0004C3 74 05            [12] 1677 	mov	a,#0x05
      0004C5 2D               [12] 1678 	add	a, r5
      0004C6 F9               [12] 1679 	mov	r1,a
      0004C7 E4               [12] 1680 	clr	a
      0004C8 3E               [12] 1681 	addc	a, r6
      0004C9 FA               [12] 1682 	mov	r2,a
      0004CA 8F 03            [24] 1683 	mov	ar3,r7
      0004CC 89 82            [24] 1684 	mov	dpl,r1
      0004CE 8A 83            [24] 1685 	mov	dph,r2
      0004D0 8B F0            [24] 1686 	mov	b,r3
      0004D2 12r00r00         [24] 1687 	lcall	__gptrget
      0004D5 F9               [12] 1688 	mov	r1,a
      0004D6 75 F0 0A         [24] 1689 	mov	b,#0x0a
      0004D9 84               [48] 1690 	div	ab
      0004DA 75 F0 0A         [24] 1691 	mov	b,#0x0a
      0004DD 84               [48] 1692 	div	ab
      0004DE AB F0            [24] 1693 	mov	r3,b
                                   1694 ;	DS1302.h:135: x1  = (time->MINUTE)%10;
      0004E0 75 F0 0A         [24] 1695 	mov	b,#0x0a
      0004E3 E9               [12] 1696 	mov	a,r1
      0004E4 84               [48] 1697 	div	ab
      0004E5 A9 F0            [24] 1698 	mov	r1,b
                                   1699 ;	DS1302.h:136: byte_data = (x10<<4) + x1;
      0004E7 EB               [12] 1700 	mov	a,r3
      0004E8 C4               [12] 1701 	swap	a
      0004E9 54 F0            [12] 1702 	anl	a,#0xf0
      0004EB 29               [12] 1703 	add	a,r1
      0004EC FB               [12] 1704 	mov	r3,a
                                   1705 ;	DS1302.h:137: ds1302_unlock_reg();
      0004ED 75*03 00         [24] 1706 	mov	_single_byte_write_PARM_2,#0x00
      0004F0 75 82 8E         [24] 1707 	mov	dpl, #0x8e
      0004F3 C0 07            [24] 1708 	push	ar7
      0004F5 C0 06            [24] 1709 	push	ar6
      0004F7 C0 05            [24] 1710 	push	ar5
      0004F9 C0 04            [24] 1711 	push	ar4
      0004FB C0 03            [24] 1712 	push	ar3
      0004FD 12r00r9A         [24] 1713 	lcall	_single_byte_write
      000500 D0 03            [24] 1714 	pop	ar3
                                   1715 ;	DS1302.h:138: single_byte_write(0x82, byte_data);
      000502 8B*03            [24] 1716 	mov	_single_byte_write_PARM_2,r3
      000504 75 82 82         [24] 1717 	mov	dpl, #0x82
      000507 12r00r9A         [24] 1718 	lcall	_single_byte_write
      00050A D0 04            [24] 1719 	pop	ar4
      00050C D0 05            [24] 1720 	pop	ar5
      00050E D0 06            [24] 1721 	pop	ar6
      000510 D0 07            [24] 1722 	pop	ar7
      000512                       1723 00104$:
                                   1724 ;	DS1302.h:141: if(SEL&0x4){
      000512 EC               [12] 1725 	mov	a,r4
      000513 30 E2 4F         [24] 1726 	jnb	acc.2,00106$
                                   1727 ;	DS1302.h:142: x10 = ((time->HOUR)/10)%10;
      000516 74 04            [12] 1728 	mov	a,#0x04
      000518 2D               [12] 1729 	add	a, r5
      000519 F9               [12] 1730 	mov	r1,a
      00051A E4               [12] 1731 	clr	a
      00051B 3E               [12] 1732 	addc	a, r6
      00051C FA               [12] 1733 	mov	r2,a
      00051D 8F 03            [24] 1734 	mov	ar3,r7
      00051F 89 82            [24] 1735 	mov	dpl,r1
      000521 8A 83            [24] 1736 	mov	dph,r2
      000523 8B F0            [24] 1737 	mov	b,r3
      000525 12r00r00         [24] 1738 	lcall	__gptrget
      000528 F9               [12] 1739 	mov	r1,a
      000529 75 F0 0A         [24] 1740 	mov	b,#0x0a
      00052C 84               [48] 1741 	div	ab
      00052D 75 F0 0A         [24] 1742 	mov	b,#0x0a
      000530 84               [48] 1743 	div	ab
      000531 AB F0            [24] 1744 	mov	r3,b
                                   1745 ;	DS1302.h:143: x1  = (time->HOUR)%10;
      000533 75 F0 0A         [24] 1746 	mov	b,#0x0a
      000536 E9               [12] 1747 	mov	a,r1
      000537 84               [48] 1748 	div	ab
      000538 A9 F0            [24] 1749 	mov	r1,b
                                   1750 ;	DS1302.h:144: byte_data = (x10<<4) + x1;
      00053A EB               [12] 1751 	mov	a,r3
      00053B C4               [12] 1752 	swap	a
      00053C 54 F0            [12] 1753 	anl	a,#0xf0
      00053E 29               [12] 1754 	add	a,r1
      00053F FB               [12] 1755 	mov	r3,a
                                   1756 ;	DS1302.h:145: ds1302_unlock_reg();
      000540 75*03 00         [24] 1757 	mov	_single_byte_write_PARM_2,#0x00
      000543 75 82 8E         [24] 1758 	mov	dpl, #0x8e
      000546 C0 07            [24] 1759 	push	ar7
      000548 C0 06            [24] 1760 	push	ar6
      00054A C0 05            [24] 1761 	push	ar5
      00054C C0 04            [24] 1762 	push	ar4
      00054E C0 03            [24] 1763 	push	ar3
      000550 12r00r9A         [24] 1764 	lcall	_single_byte_write
      000553 D0 03            [24] 1765 	pop	ar3
                                   1766 ;	DS1302.h:146: single_byte_write(0x84, byte_data);
      000555 8B*03            [24] 1767 	mov	_single_byte_write_PARM_2,r3
      000557 75 82 84         [24] 1768 	mov	dpl, #0x84
      00055A 12r00r9A         [24] 1769 	lcall	_single_byte_write
      00055D D0 04            [24] 1770 	pop	ar4
      00055F D0 05            [24] 1771 	pop	ar5
      000561 D0 06            [24] 1772 	pop	ar6
      000563 D0 07            [24] 1773 	pop	ar7
      000565                       1774 00106$:
                                   1775 ;	DS1302.h:149: if(SEL&0x8){
      000565 EC               [12] 1776 	mov	a,r4
      000566 30 E3 4F         [24] 1777 	jnb	acc.3,00108$
                                   1778 ;	DS1302.h:150: x10 = ((time->DATE)/10)%10;
      000569 74 01            [12] 1779 	mov	a,#0x01
      00056B 2D               [12] 1780 	add	a, r5
      00056C F9               [12] 1781 	mov	r1,a
      00056D E4               [12] 1782 	clr	a
      00056E 3E               [12] 1783 	addc	a, r6
      00056F FA               [12] 1784 	mov	r2,a
      000570 8F 03            [24] 1785 	mov	ar3,r7
      000572 89 82            [24] 1786 	mov	dpl,r1
      000574 8A 83            [24] 1787 	mov	dph,r2
      000576 8B F0            [24] 1788 	mov	b,r3
      000578 12r00r00         [24] 1789 	lcall	__gptrget
      00057B F9               [12] 1790 	mov	r1,a
      00057C 75 F0 0A         [24] 1791 	mov	b,#0x0a
      00057F 84               [48] 1792 	div	ab
      000580 75 F0 0A         [24] 1793 	mov	b,#0x0a
      000583 84               [48] 1794 	div	ab
      000584 AB F0            [24] 1795 	mov	r3,b
                                   1796 ;	DS1302.h:151: x1  = (time->DATE)%10;
      000586 75 F0 0A         [24] 1797 	mov	b,#0x0a
      000589 E9               [12] 1798 	mov	a,r1
      00058A 84               [48] 1799 	div	ab
      00058B A9 F0            [24] 1800 	mov	r1,b
                                   1801 ;	DS1302.h:152: byte_data = (x10<<4) + x1;
      00058D EB               [12] 1802 	mov	a,r3
      00058E C4               [12] 1803 	swap	a
      00058F 54 F0            [12] 1804 	anl	a,#0xf0
      000591 29               [12] 1805 	add	a,r1
      000592 F9               [12] 1806 	mov	r1,a
                                   1807 ;	DS1302.h:153: ds1302_unlock_reg();
      000593 75*03 00         [24] 1808 	mov	_single_byte_write_PARM_2,#0x00
      000596 75 82 8E         [24] 1809 	mov	dpl, #0x8e
      000599 C0 07            [24] 1810 	push	ar7
      00059B C0 06            [24] 1811 	push	ar6
      00059D C0 05            [24] 1812 	push	ar5
      00059F C0 04            [24] 1813 	push	ar4
      0005A1 C0 01            [24] 1814 	push	ar1
      0005A3 12r00r9A         [24] 1815 	lcall	_single_byte_write
      0005A6 D0 01            [24] 1816 	pop	ar1
                                   1817 ;	DS1302.h:154: single_byte_write(0x86, byte_data);
      0005A8 89*03            [24] 1818 	mov	_single_byte_write_PARM_2,r1
      0005AA 75 82 86         [24] 1819 	mov	dpl, #0x86
      0005AD 12r00r9A         [24] 1820 	lcall	_single_byte_write
      0005B0 D0 04            [24] 1821 	pop	ar4
      0005B2 D0 05            [24] 1822 	pop	ar5
      0005B4 D0 06            [24] 1823 	pop	ar6
      0005B6 D0 07            [24] 1824 	pop	ar7
      0005B8                       1825 00108$:
                                   1826 ;	DS1302.h:157: if(SEL&0x10){
      0005B8 EC               [12] 1827 	mov	a,r4
      0005B9 30 E4 4F         [24] 1828 	jnb	acc.4,00110$
                                   1829 ;	DS1302.h:158: x10 = ((time->MONTH)/10)%10;
      0005BC 74 02            [12] 1830 	mov	a,#0x02
      0005BE 2D               [12] 1831 	add	a, r5
      0005BF F9               [12] 1832 	mov	r1,a
      0005C0 E4               [12] 1833 	clr	a
      0005C1 3E               [12] 1834 	addc	a, r6
      0005C2 FA               [12] 1835 	mov	r2,a
      0005C3 8F 03            [24] 1836 	mov	ar3,r7
      0005C5 89 82            [24] 1837 	mov	dpl,r1
      0005C7 8A 83            [24] 1838 	mov	dph,r2
      0005C9 8B F0            [24] 1839 	mov	b,r3
      0005CB 12r00r00         [24] 1840 	lcall	__gptrget
      0005CE F9               [12] 1841 	mov	r1,a
      0005CF 75 F0 0A         [24] 1842 	mov	b,#0x0a
      0005D2 84               [48] 1843 	div	ab
      0005D3 75 F0 0A         [24] 1844 	mov	b,#0x0a
      0005D6 84               [48] 1845 	div	ab
      0005D7 AB F0            [24] 1846 	mov	r3,b
                                   1847 ;	DS1302.h:159: x1  = (time->MONTH)%10;
      0005D9 75 F0 0A         [24] 1848 	mov	b,#0x0a
      0005DC E9               [12] 1849 	mov	a,r1
      0005DD 84               [48] 1850 	div	ab
      0005DE A9 F0            [24] 1851 	mov	r1,b
                                   1852 ;	DS1302.h:160: byte_data = (x10<<4) + x1;
      0005E0 EB               [12] 1853 	mov	a,r3
      0005E1 C4               [12] 1854 	swap	a
      0005E2 54 F0            [12] 1855 	anl	a,#0xf0
      0005E4 29               [12] 1856 	add	a,r1
      0005E5 FB               [12] 1857 	mov	r3,a
                                   1858 ;	DS1302.h:161: ds1302_unlock_reg();
      0005E6 75*03 00         [24] 1859 	mov	_single_byte_write_PARM_2,#0x00
      0005E9 75 82 8E         [24] 1860 	mov	dpl, #0x8e
      0005EC C0 07            [24] 1861 	push	ar7
      0005EE C0 06            [24] 1862 	push	ar6
      0005F0 C0 05            [24] 1863 	push	ar5
      0005F2 C0 04            [24] 1864 	push	ar4
      0005F4 C0 03            [24] 1865 	push	ar3
      0005F6 12r00r9A         [24] 1866 	lcall	_single_byte_write
      0005F9 D0 03            [24] 1867 	pop	ar3
                                   1868 ;	DS1302.h:162: single_byte_write(0x88, byte_data);
      0005FB 8B*03            [24] 1869 	mov	_single_byte_write_PARM_2,r3
      0005FD 75 82 88         [24] 1870 	mov	dpl, #0x88
      000600 12r00r9A         [24] 1871 	lcall	_single_byte_write
      000603 D0 04            [24] 1872 	pop	ar4
      000605 D0 05            [24] 1873 	pop	ar5
      000607 D0 06            [24] 1874 	pop	ar6
      000609 D0 07            [24] 1875 	pop	ar7
      00060B                       1876 00110$:
                                   1877 ;	DS1302.h:165: if(SEL&0x20){
      00060B EC               [12] 1878 	mov	a,r4
      00060C 30 E5 4F         [24] 1879 	jnb	acc.5,00112$
                                   1880 ;	DS1302.h:166: x10 = ((time->YEAR)/10)%10;
      00060F 74 03            [12] 1881 	mov	a,#0x03
      000611 2D               [12] 1882 	add	a, r5
      000612 F9               [12] 1883 	mov	r1,a
      000613 E4               [12] 1884 	clr	a
      000614 3E               [12] 1885 	addc	a, r6
      000615 FA               [12] 1886 	mov	r2,a
      000616 8F 03            [24] 1887 	mov	ar3,r7
      000618 89 82            [24] 1888 	mov	dpl,r1
      00061A 8A 83            [24] 1889 	mov	dph,r2
      00061C 8B F0            [24] 1890 	mov	b,r3
      00061E 12r00r00         [24] 1891 	lcall	__gptrget
      000621 F9               [12] 1892 	mov	r1,a
      000622 75 F0 0A         [24] 1893 	mov	b,#0x0a
      000625 84               [48] 1894 	div	ab
      000626 75 F0 0A         [24] 1895 	mov	b,#0x0a
      000629 84               [48] 1896 	div	ab
      00062A AB F0            [24] 1897 	mov	r3,b
                                   1898 ;	DS1302.h:167: x1  = (time->YEAR)%10;
      00062C 75 F0 0A         [24] 1899 	mov	b,#0x0a
      00062F E9               [12] 1900 	mov	a,r1
      000630 84               [48] 1901 	div	ab
      000631 A9 F0            [24] 1902 	mov	r1,b
                                   1903 ;	DS1302.h:168: byte_data = (x10<<4) + x1;
      000633 EB               [12] 1904 	mov	a,r3
      000634 C4               [12] 1905 	swap	a
      000635 54 F0            [12] 1906 	anl	a,#0xf0
      000637 29               [12] 1907 	add	a,r1
      000638 FB               [12] 1908 	mov	r3,a
                                   1909 ;	DS1302.h:169: ds1302_unlock_reg();
      000639 75*03 00         [24] 1910 	mov	_single_byte_write_PARM_2,#0x00
      00063C 75 82 8E         [24] 1911 	mov	dpl, #0x8e
      00063F C0 07            [24] 1912 	push	ar7
      000641 C0 06            [24] 1913 	push	ar6
      000643 C0 05            [24] 1914 	push	ar5
      000645 C0 04            [24] 1915 	push	ar4
      000647 C0 03            [24] 1916 	push	ar3
      000649 12r00r9A         [24] 1917 	lcall	_single_byte_write
      00064C D0 03            [24] 1918 	pop	ar3
                                   1919 ;	DS1302.h:170: single_byte_write(0x9C, byte_data);
      00064E 8B*03            [24] 1920 	mov	_single_byte_write_PARM_2,r3
      000650 75 82 9C         [24] 1921 	mov	dpl, #0x9c
      000653 12r00r9A         [24] 1922 	lcall	_single_byte_write
      000656 D0 04            [24] 1923 	pop	ar4
      000658 D0 05            [24] 1924 	pop	ar5
      00065A D0 06            [24] 1925 	pop	ar6
      00065C D0 07            [24] 1926 	pop	ar7
      00065E                       1927 00112$:
                                   1928 ;	DS1302.h:173: if(SEL&0x40){
      00065E EC               [12] 1929 	mov	a,r4
      00065F 30 E6 24         [24] 1930 	jnb	acc.6,00115$
                                   1931 ;	DS1302.h:174: x1  = (time->DAY)%10;
      000662 8D 82            [24] 1932 	mov	dpl,r5
      000664 8E 83            [24] 1933 	mov	dph,r6
      000666 8F F0            [24] 1934 	mov	b,r7
      000668 12r00r00         [24] 1935 	lcall	__gptrget
      00066B 75 F0 0A         [24] 1936 	mov	b,#0x0a
      00066E 84               [48] 1937 	div	ab
      00066F AD F0            [24] 1938 	mov	r5,b
                                   1939 ;	DS1302.h:175: ds1302_unlock_reg();
      000671 75*03 00         [24] 1940 	mov	_single_byte_write_PARM_2,#0x00
      000674 75 82 8E         [24] 1941 	mov	dpl, #0x8e
      000677 C0 05            [24] 1942 	push	ar5
      000679 12r00r9A         [24] 1943 	lcall	_single_byte_write
      00067C D0 05            [24] 1944 	pop	ar5
                                   1945 ;	DS1302.h:176: single_byte_write(0x9A, x1);
      00067E 8D*03            [24] 1946 	mov	_single_byte_write_PARM_2,r5
      000680 75 82 9A         [24] 1947 	mov	dpl, #0x9a
                                   1948 ;	DS1302.h:178: }
      000683 02r00r9A         [24] 1949 	ljmp	_single_byte_write
      000686                       1950 00115$:
      000686 22               [24] 1951 	ret
                                   1952 ;------------------------------------------------------------
                                   1953 ;Allocation info for local variables in function 'ds1302_initial'
                                   1954 ;------------------------------------------------------------
                                   1955 ;	DS1302.h:180: void ds1302_initial(){
                                   1956 ;	-----------------------------------------
                                   1957 ;	 function ds1302_initial
                                   1958 ;	-----------------------------------------
      000687                       1959 _ds1302_initial:
                                   1960 ;	DS1302.h:181: ThreeWiresProtocol_Initial();
                                   1961 ;	DS1302.h:182: }
      000687 02r01rFD         [24] 1962 	ljmp	_ThreeWiresProtocol_Initial
                                   1963 ;------------------------------------------------------------
                                   1964 ;Allocation info for local variables in function 'led7seg_disp'
                                   1965 ;------------------------------------------------------------
                                   1966 ;CODE          Allocated with name '_led7seg_disp_PARM_2'
                                   1967 ;POS           Allocated to registers r7 
                                   1968 ;------------------------------------------------------------
                                   1969 ;	LED7Seg_OnKit.h:36: void led7seg_disp(uint8  POS, uint8  CODE){
                                   1970 ;	-----------------------------------------
                                   1971 ;	 function led7seg_disp
                                   1972 ;	-----------------------------------------
      00068A                       1973 _led7seg_disp:
                                   1974 ;	LED7Seg_OnKit.h:37: switch (POS) {
      00068A E5 82            [12] 1975 	mov	a,dpl
      00068C FF               [12] 1976 	mov	r7,a
      00068D 24 F7            [12] 1977 	add	a,#0xff - 0x08
      00068F 50 03            [24] 1978 	jnc	00119$
      000691 02r07r04         [24] 1979 	ljmp	00109$
      000694                       1980 00119$:
      000694 EF               [12] 1981 	mov	a,r7
      000695 24 0A            [12] 1982 	add	a,#(00120$-3-.)
      000697 83               [24] 1983 	movc	a,@a+pc
      000698 F5 82            [12] 1984 	mov	dpl,a
      00069A EF               [12] 1985 	mov	a,r7
      00069B 24 0D            [12] 1986 	add	a,#(00121$-3-.)
      00069D 83               [24] 1987 	movc	a,@a+pc
      00069E F5 83            [12] 1988 	mov	dph,a
      0006A0 E4               [12] 1989 	clr	a
      0006A1 73               [24] 1990 	jmp	@a+dptr
      0006A2                       1991 00120$:
      0006A2r04                    1992 	.db	00109$
      0006A3rB4                    1993 	.db	00101$
      0006A4rBE                    1994 	.db	00102$
      0006A5rC8                    1995 	.db	00103$
      0006A6rD2                    1996 	.db	00104$
      0006A7rDC                    1997 	.db	00105$
      0006A8rE6                    1998 	.db	00106$
      0006A9rF0                    1999 	.db	00107$
      0006AArFA                    2000 	.db	00108$
      0006AB                       2001 00121$:
      0006ABs07                    2002 	.db	00109$>>8
      0006ACs06                    2003 	.db	00101$>>8
      0006ADs06                    2004 	.db	00102$>>8
      0006AEs06                    2005 	.db	00103$>>8
      0006AFs06                    2006 	.db	00104$>>8
      0006B0s06                    2007 	.db	00105$>>8
      0006B1s06                    2008 	.db	00106$>>8
      0006B2s06                    2009 	.db	00107$>>8
      0006B3s06                    2010 	.db	00108$>>8
                                   2011 ;	LED7Seg_OnKit.h:38: case 0x1:
      0006B4                       2012 00101$:
                                   2013 ;	LED7Seg_OnKit.h:39: { GND0 = 0; GND1 = 0; GND2 = 0; LED_7SEG = CODE; return;}
                                   2014 ;	assignBit
      0006B4 C2 A2            [12] 2015 	clr	_GND0
                                   2016 ;	assignBit
      0006B6 C2 A3            [12] 2017 	clr	_GND1
                                   2018 ;	assignBit
      0006B8 C2 A4            [12] 2019 	clr	_GND2
      0006BA 85*00 80         [24] 2020 	mov	_P0,_led7seg_disp_PARM_2
                                   2021 ;	LED7Seg_OnKit.h:40: case 0x2:
      0006BD 22               [24] 2022 	ret
      0006BE                       2023 00102$:
                                   2024 ;	LED7Seg_OnKit.h:41: { GND0 = 1; GND1 = 0; GND2 = 0; LED_7SEG = CODE; return;}
                                   2025 ;	assignBit
      0006BE D2 A2            [12] 2026 	setb	_GND0
                                   2027 ;	assignBit
      0006C0 C2 A3            [12] 2028 	clr	_GND1
                                   2029 ;	assignBit
      0006C2 C2 A4            [12] 2030 	clr	_GND2
      0006C4 85*00 80         [24] 2031 	mov	_P0,_led7seg_disp_PARM_2
                                   2032 ;	LED7Seg_OnKit.h:42: case 0x3:
      0006C7 22               [24] 2033 	ret
      0006C8                       2034 00103$:
                                   2035 ;	LED7Seg_OnKit.h:43: { GND0 = 0; GND1 = 1; GND2 = 0; LED_7SEG = CODE; return;}
                                   2036 ;	assignBit
      0006C8 C2 A2            [12] 2037 	clr	_GND0
                                   2038 ;	assignBit
      0006CA D2 A3            [12] 2039 	setb	_GND1
                                   2040 ;	assignBit
      0006CC C2 A4            [12] 2041 	clr	_GND2
      0006CE 85*00 80         [24] 2042 	mov	_P0,_led7seg_disp_PARM_2
                                   2043 ;	LED7Seg_OnKit.h:44: case 0x4:
      0006D1 22               [24] 2044 	ret
      0006D2                       2045 00104$:
                                   2046 ;	LED7Seg_OnKit.h:45: { GND0 = 1; GND1 = 1; GND2 = 0; LED_7SEG = CODE; return;}
                                   2047 ;	assignBit
      0006D2 D2 A2            [12] 2048 	setb	_GND0
                                   2049 ;	assignBit
      0006D4 D2 A3            [12] 2050 	setb	_GND1
                                   2051 ;	assignBit
      0006D6 C2 A4            [12] 2052 	clr	_GND2
      0006D8 85*00 80         [24] 2053 	mov	_P0,_led7seg_disp_PARM_2
                                   2054 ;	LED7Seg_OnKit.h:46: case 0x5:
      0006DB 22               [24] 2055 	ret
      0006DC                       2056 00105$:
                                   2057 ;	LED7Seg_OnKit.h:47: { GND0 = 0; GND1 = 0; GND2 = 1; LED_7SEG = CODE; return;}
                                   2058 ;	assignBit
      0006DC C2 A2            [12] 2059 	clr	_GND0
                                   2060 ;	assignBit
      0006DE C2 A3            [12] 2061 	clr	_GND1
                                   2062 ;	assignBit
      0006E0 D2 A4            [12] 2063 	setb	_GND2
      0006E2 85*00 80         [24] 2064 	mov	_P0,_led7seg_disp_PARM_2
                                   2065 ;	LED7Seg_OnKit.h:48: case 0x6:
      0006E5 22               [24] 2066 	ret
      0006E6                       2067 00106$:
                                   2068 ;	LED7Seg_OnKit.h:49: { GND0 = 1; GND1 = 0; GND2 = 1; LED_7SEG = CODE; return;}
                                   2069 ;	assignBit
      0006E6 D2 A2            [12] 2070 	setb	_GND0
                                   2071 ;	assignBit
      0006E8 C2 A3            [12] 2072 	clr	_GND1
                                   2073 ;	assignBit
      0006EA D2 A4            [12] 2074 	setb	_GND2
      0006EC 85*00 80         [24] 2075 	mov	_P0,_led7seg_disp_PARM_2
                                   2076 ;	LED7Seg_OnKit.h:50: case 0x7:
      0006EF 22               [24] 2077 	ret
      0006F0                       2078 00107$:
                                   2079 ;	LED7Seg_OnKit.h:51: { GND0 = 0; GND1 = 1; GND2 = 1; LED_7SEG = CODE; return;}
                                   2080 ;	assignBit
      0006F0 C2 A2            [12] 2081 	clr	_GND0
                                   2082 ;	assignBit
      0006F2 D2 A3            [12] 2083 	setb	_GND1
                                   2084 ;	assignBit
      0006F4 D2 A4            [12] 2085 	setb	_GND2
      0006F6 85*00 80         [24] 2086 	mov	_P0,_led7seg_disp_PARM_2
                                   2087 ;	LED7Seg_OnKit.h:52: case 0x8:
      0006F9 22               [24] 2088 	ret
      0006FA                       2089 00108$:
                                   2090 ;	LED7Seg_OnKit.h:53: { GND0 = 1; GND1 = 1; GND2 = 1; LED_7SEG = CODE; return;}
                                   2091 ;	assignBit
      0006FA D2 A2            [12] 2092 	setb	_GND0
                                   2093 ;	assignBit
      0006FC D2 A3            [12] 2094 	setb	_GND1
                                   2095 ;	assignBit
      0006FE D2 A4            [12] 2096 	setb	_GND2
      000700 85*00 80         [24] 2097 	mov	_P0,_led7seg_disp_PARM_2
                                   2098 ;	LED7Seg_OnKit.h:54: default:
      000703 22               [24] 2099 	ret
      000704                       2100 00109$:
                                   2101 ;	LED7Seg_OnKit.h:55: LED_7SEG = 0x0;
      000704 75 80 00         [24] 2102 	mov	_P0,#0x00
                                   2103 ;	LED7Seg_OnKit.h:56: }
                                   2104 ;	LED7Seg_OnKit.h:57: }
      000707 22               [24] 2105 	ret
                                   2106 ;------------------------------------------------------------
                                   2107 ;Allocation info for local variables in function 'Disp8leds7seg'
                                   2108 ;------------------------------------------------------------
                                   2109 ;ms_disp_t     Allocated to registers r6 r7 
                                   2110 ;i             Allocated to registers r3 
                                   2111 ;j             Allocated to registers r4 r5 
                                   2112 ;------------------------------------------------------------
                                   2113 ;	LED7Seg_OnKit.h:70: void Disp8leds7seg(uint32 ms_disp_t){
                                   2114 ;	-----------------------------------------
                                   2115 ;	 function Disp8leds7seg
                                   2116 ;	-----------------------------------------
      000708                       2117 _Disp8leds7seg:
      000708 AE 82            [24] 2118 	mov	r6, dpl
      00070A AF 83            [24] 2119 	mov	r7, dph
                                   2120 ;	LED7Seg_OnKit.h:73: REP(j, 1, ms_disp_t)
      00070C 7C 01            [12] 2121 	mov	r4,#0x01
      00070E 7D 00            [12] 2122 	mov	r5,#0x00
      000710                       2123 00106$:
      000710 C3               [12] 2124 	clr	c
      000711 EE               [12] 2125 	mov	a,r6
      000712 9C               [12] 2126 	subb	a,r4
      000713 EF               [12] 2127 	mov	a,r7
      000714 9D               [12] 2128 	subb	a,r5
      000715 40 3B            [24] 2129 	jc	00108$
                                   2130 ;	LED7Seg_OnKit.h:74: REP(i, 0, 7){
      000717 7B 00            [12] 2131 	mov	r3,#0x00
      000719                       2132 00103$:
                                   2133 ;	LED7Seg_OnKit.h:75: led7seg_disp(i+1, LED[i]);
      000719 8B 02            [24] 2134 	mov	ar2,r3
      00071B EA               [12] 2135 	mov	a,r2
      00071C 04               [12] 2136 	inc	a
      00071D F5 82            [12] 2137 	mov	dpl,a
      00071F EB               [12] 2138 	mov	a,r3
      000720 24r18            [12] 2139 	add	a, #_LED
      000722 F9               [12] 2140 	mov	r1,a
      000723 87*00            [24] 2141 	mov	_led7seg_disp_PARM_2,@r1
      000725 C0 07            [24] 2142 	push	ar7
      000727 C0 06            [24] 2143 	push	ar6
      000729 C0 05            [24] 2144 	push	ar5
      00072B C0 04            [24] 2145 	push	ar4
      00072D C0 03            [24] 2146 	push	ar3
      00072F 12r06r8A         [24] 2147 	lcall	_led7seg_disp
                                   2148 ;	LED7Seg_OnKit.h:76: delay_us(5);
      000732 90 00 05         [24] 2149 	mov	dptr,#0x0005
      000735 12r00r00         [24] 2150 	lcall	_delay_us
      000738 D0 03            [24] 2151 	pop	ar3
      00073A D0 04            [24] 2152 	pop	ar4
      00073C D0 05            [24] 2153 	pop	ar5
      00073E D0 06            [24] 2154 	pop	ar6
      000740 D0 07            [24] 2155 	pop	ar7
                                   2156 ;	LED7Seg_OnKit.h:77: LED_7SEG = 0x0;
      000742 75 80 00         [24] 2157 	mov	_P0,#0x00
                                   2158 ;	LED7Seg_OnKit.h:74: REP(i, 0, 7){
      000745 0B               [12] 2159 	inc	r3
      000746 EB               [12] 2160 	mov	a,r3
      000747 24 F8            [12] 2161 	add	a,#0xff - 0x07
      000749 50 CE            [24] 2162 	jnc	00103$
                                   2163 ;	LED7Seg_OnKit.h:73: REP(j, 1, ms_disp_t)
      00074B 0C               [12] 2164 	inc	r4
      00074C BC 00 C1         [24] 2165 	cjne	r4,#0x00,00106$
      00074F 0D               [12] 2166 	inc	r5
      000750 80 BE            [24] 2167 	sjmp	00106$
      000752                       2168 00108$:
                                   2169 ;	LED7Seg_OnKit.h:79: }
      000752 22               [24] 2170 	ret
                                   2171 ;------------------------------------------------------------
                                   2172 ;Allocation info for local variables in function 'Row_Write'
                                   2173 ;------------------------------------------------------------
                                   2174 ;I             Allocated to registers r7 
                                   2175 ;------------------------------------------------------------
                                   2176 ;	Matrix_Button.h:24: void Row_Write(uint8 I){
                                   2177 ;	-----------------------------------------
                                   2178 ;	 function Row_Write
                                   2179 ;	-----------------------------------------
      000753                       2180 _Row_Write:
                                   2181 ;	Matrix_Button.h:25: switch (I){
      000753 E5 82            [12] 2182 	mov	a,dpl
      000755 FF               [12] 2183 	mov	r7,a
      000756 24 FC            [12] 2184 	add	a,#0xff - 0x03
      000758 40 31            [24] 2185 	jc	00106$
      00075A EF               [12] 2186 	mov	a,r7
      00075B 2F               [12] 2187 	add	a,r7
                                   2188 ;	Matrix_Button.h:26: case 0:
      00075C 90r07r60         [24] 2189 	mov	dptr,#00115$
      00075F 73               [24] 2190 	jmp	@a+dptr
      000760                       2191 00115$:
      000760 80 06            [24] 2192 	sjmp	00101$
      000762 80 0D            [24] 2193 	sjmp	00102$
      000764 80 14            [24] 2194 	sjmp	00103$
      000766 80 1B            [24] 2195 	sjmp	00104$
      000768                       2196 00101$:
                                   2197 ;	Matrix_Button.h:27: ROW0 = 0; ROW1 = 1; ROW2 = 1; ROW3 = 1;
                                   2198 ;	assignBit
      000768 C2 97            [12] 2199 	clr	_ROW0
                                   2200 ;	assignBit
      00076A D2 96            [12] 2201 	setb	_ROW1
                                   2202 ;	assignBit
      00076C D2 95            [12] 2203 	setb	_ROW2
                                   2204 ;	assignBit
      00076E D2 94            [12] 2205 	setb	_ROW3
                                   2206 ;	Matrix_Button.h:28: break;
                                   2207 ;	Matrix_Button.h:29: case 1:
      000770 22               [24] 2208 	ret
      000771                       2209 00102$:
                                   2210 ;	Matrix_Button.h:30: ROW0 = 1; ROW1 = 0; ROW2 = 1; ROW3 = 1;
                                   2211 ;	assignBit
      000771 D2 97            [12] 2212 	setb	_ROW0
                                   2213 ;	assignBit
      000773 C2 96            [12] 2214 	clr	_ROW1
                                   2215 ;	assignBit
      000775 D2 95            [12] 2216 	setb	_ROW2
                                   2217 ;	assignBit
      000777 D2 94            [12] 2218 	setb	_ROW3
                                   2219 ;	Matrix_Button.h:31: break;
                                   2220 ;	Matrix_Button.h:32: case 2:
      000779 22               [24] 2221 	ret
      00077A                       2222 00103$:
                                   2223 ;	Matrix_Button.h:33: ROW0 = 1;  ROW1 = 1; ROW2 = 0; ROW3 = 1;
                                   2224 ;	assignBit
      00077A D2 97            [12] 2225 	setb	_ROW0
                                   2226 ;	assignBit
      00077C D2 96            [12] 2227 	setb	_ROW1
                                   2228 ;	assignBit
      00077E C2 95            [12] 2229 	clr	_ROW2
                                   2230 ;	assignBit
      000780 D2 94            [12] 2231 	setb	_ROW3
                                   2232 ;	Matrix_Button.h:34: break;
                                   2233 ;	Matrix_Button.h:35: case 3:
      000782 22               [24] 2234 	ret
      000783                       2235 00104$:
                                   2236 ;	Matrix_Button.h:36: ROW0 = 1;  ROW1 = 1; ROW2 = 1; ROW3 = 0;
                                   2237 ;	assignBit
      000783 D2 97            [12] 2238 	setb	_ROW0
                                   2239 ;	assignBit
      000785 D2 96            [12] 2240 	setb	_ROW1
                                   2241 ;	assignBit
      000787 D2 95            [12] 2242 	setb	_ROW2
                                   2243 ;	assignBit
      000789 C2 94            [12] 2244 	clr	_ROW3
                                   2245 ;	Matrix_Button.h:38: }
      00078B                       2246 00106$:
                                   2247 ;	Matrix_Button.h:39: }
      00078B 22               [24] 2248 	ret
                                   2249 ;------------------------------------------------------------
                                   2250 ;Allocation info for local variables in function 'Col_Read'
                                   2251 ;------------------------------------------------------------
                                   2252 ;COL           Allocated to registers r6 r7 
                                   2253 ;------------------------------------------------------------
                                   2254 ;	Matrix_Button.h:41: uint32 Col_Read(){
                                   2255 ;	-----------------------------------------
                                   2256 ;	 function Col_Read
                                   2257 ;	-----------------------------------------
      00078C                       2258 _Col_Read:
                                   2259 ;	Matrix_Button.h:42: uint32 COL = 0;
      00078C 7E 00            [12] 2260 	mov	r6,#0x00
      00078E 7F 00            [12] 2261 	mov	r7,#0x00
                                   2262 ;	Matrix_Button.h:43: if(COL0 == 0) COL += 1;
      000790 20 93 04         [24] 2263 	jb	_COL0,00102$
      000793 7E 01            [12] 2264 	mov	r6,#0x01
      000795 7F 00            [12] 2265 	mov	r7,#0x00
      000797                       2266 00102$:
                                   2267 ;	Matrix_Button.h:44: if(COL1 == 0) COL += 2;
      000797 20 92 07         [24] 2268 	jb	_COL1,00104$
      00079A 74 02            [12] 2269 	mov	a,#0x02
      00079C 2E               [12] 2270 	add	a, r6
      00079D FE               [12] 2271 	mov	r6,a
      00079E E4               [12] 2272 	clr	a
      00079F 3F               [12] 2273 	addc	a, r7
      0007A0 FF               [12] 2274 	mov	r7,a
      0007A1                       2275 00104$:
                                   2276 ;	Matrix_Button.h:45: if(COL2 == 0) COL += 4;
      0007A1 20 91 07         [24] 2277 	jb	_COL2,00106$
      0007A4 74 04            [12] 2278 	mov	a,#0x04
      0007A6 2E               [12] 2279 	add	a, r6
      0007A7 FE               [12] 2280 	mov	r6,a
      0007A8 E4               [12] 2281 	clr	a
      0007A9 3F               [12] 2282 	addc	a, r7
      0007AA FF               [12] 2283 	mov	r7,a
      0007AB                       2284 00106$:
                                   2285 ;	Matrix_Button.h:46: if(COL3 == 0) COL += 8;
      0007AB 20 90 06         [24] 2286 	jb	_COL3,00108$
      0007AE 74 08            [12] 2287 	mov	a,#0x08
      0007B0 2E               [12] 2288 	add	a, r6
      0007B1 FE               [12] 2289 	mov	r6,a
      0007B2 E4               [12] 2290 	clr	a
      0007B3 3F               [12] 2291 	addc	a, r7
      0007B4                       2292 00108$:
                                   2293 ;	Matrix_Button.h:47: return COL&0x0F;
      0007B4 74 0F            [12] 2294 	mov	a,#0x0f
      0007B6 5E               [12] 2295 	anl	a,r6
      0007B7 F5 82            [12] 2296 	mov	dpl,a
      0007B9 75 83 00         [24] 2297 	mov	dph,#0x00
                                   2298 ;	Matrix_Button.h:48: }
      0007BC 22               [24] 2299 	ret
                                   2300 ;------------------------------------------------------------
                                   2301 ;Allocation info for local variables in function 'Get_BTN_MATRIX'
                                   2302 ;------------------------------------------------------------
                                   2303 ;i             Allocated to registers r7 
                                   2304 ;------------------------------------------------------------
                                   2305 ;	Matrix_Button.h:50: uint32 Get_BTN_MATRIX(){
                                   2306 ;	-----------------------------------------
                                   2307 ;	 function Get_BTN_MATRIX
                                   2308 ;	-----------------------------------------
      0007BD                       2309 _Get_BTN_MATRIX:
                                   2310 ;	Matrix_Button.h:52: BTN_MATRIX = 0;
      0007BD E4               [12] 2311 	clr	a
      0007BE F5*20            [12] 2312 	mov	_BTN_MATRIX,a
      0007C0 F5*21            [12] 2313 	mov	(_BTN_MATRIX + 1),a
                                   2314 ;	Matrix_Button.h:53: for(i = 0; i < 4; ++i){
      0007C2 FF               [12] 2315 	mov	r7,a
      0007C3                       2316 00102$:
                                   2317 ;	Matrix_Button.h:54: Row_Write(i);
      0007C3 8F 06            [24] 2318 	mov	ar6,r7
      0007C5 8E 82            [24] 2319 	mov	dpl, r6
      0007C7 C0 07            [24] 2320 	push	ar7
      0007C9 C0 06            [24] 2321 	push	ar6
      0007CB 12r07r53         [24] 2322 	lcall	_Row_Write
                                   2323 ;	Matrix_Button.h:56: BTN_MATRIX |= (Col_Read()<<(4*i));
      0007CE 12r07r8C         [24] 2324 	lcall	_Col_Read
      0007D1 AC 82            [24] 2325 	mov	r4, dpl
      0007D3 AD 83            [24] 2326 	mov	r5, dph
      0007D5 D0 06            [24] 2327 	pop	ar6
      0007D7 D0 07            [24] 2328 	pop	ar7
      0007D9 EE               [12] 2329 	mov	a,r6
      0007DA 2E               [12] 2330 	add	a,r6
      0007DB 25 E0            [12] 2331 	add	a,acc
      0007DD F5 F0            [12] 2332 	mov	b, a
      0007DF 05 F0            [12] 2333 	inc	b
      0007E1 80 06            [24] 2334 	sjmp	00120$
      0007E3                       2335 00119$:
      0007E3 EC               [12] 2336 	mov	a,r4
      0007E4 2C               [12] 2337 	add	a,r4
      0007E5 FC               [12] 2338 	mov	r4,a
      0007E6 ED               [12] 2339 	mov	a,r5
      0007E7 33               [12] 2340 	rlc	a
      0007E8 FD               [12] 2341 	mov	r5,a
      0007E9                       2342 00120$:
      0007E9 D5 F0 F7         [24] 2343 	djnz	b,00119$
      0007EC EC               [12] 2344 	mov	a,r4
      0007ED 42*20            [12] 2345 	orl	_BTN_MATRIX,a
      0007EF ED               [12] 2346 	mov	a,r5
      0007F0 42*21            [12] 2347 	orl	(_BTN_MATRIX + 1),a
                                   2348 ;	Matrix_Button.h:53: for(i = 0; i < 4; ++i){
      0007F2 0F               [12] 2349 	inc	r7
      0007F3 BF 04 00         [24] 2350 	cjne	r7,#0x04,00121$
      0007F6                       2351 00121$:
      0007F6 40 CB            [24] 2352 	jc	00102$
                                   2353 ;	Matrix_Button.h:58: return BTN_MATRIX;
      0007F8 85*20 82         [24] 2354 	mov	dpl, _BTN_MATRIX
      0007FB 85*21 83         [24] 2355 	mov	dph, (_BTN_MATRIX + 1)
                                   2356 ;	Matrix_Button.h:59: }
      0007FE 22               [24] 2357 	ret
                                   2358 ;------------------------------------------------------------
                                   2359 ;Allocation info for local variables in function 'Get_BTN_MATRIX_2'
                                   2360 ;------------------------------------------------------------
                                   2361 ;current_btn_matrix Allocated to registers r6 r7 
                                   2362 ;------------------------------------------------------------
                                   2363 ;	Matrix_Button.h:62: uint32 Get_BTN_MATRIX_2(){
                                   2364 ;	-----------------------------------------
                                   2365 ;	 function Get_BTN_MATRIX_2
                                   2366 ;	-----------------------------------------
      0007FF                       2367 _Get_BTN_MATRIX_2:
                                   2368 ;	Matrix_Button.h:63: uint32 current_btn_matrix = Get_BTN_MATRIX();
      0007FF 12r07rBD         [24] 2369 	lcall	_Get_BTN_MATRIX
      000802 AE 82            [24] 2370 	mov	r6, dpl
      000804 AF 83            [24] 2371 	mov	r7, dph
                                   2372 ;	Matrix_Button.h:64: while( current_btn_matrix == Get_BTN_MATRIX()){
      000806                       2373 00101$:
      000806 C0 07            [24] 2374 	push	ar7
      000808 C0 06            [24] 2375 	push	ar6
      00080A 12r07rBD         [24] 2376 	lcall	_Get_BTN_MATRIX
      00080D AC 82            [24] 2377 	mov	r4, dpl
      00080F AD 83            [24] 2378 	mov	r5, dph
      000811 D0 06            [24] 2379 	pop	ar6
      000813 D0 07            [24] 2380 	pop	ar7
      000815 EE               [12] 2381 	mov	a,r6
      000816 B5 04 0D         [24] 2382 	cjne	a,ar4,00103$
      000819 EF               [12] 2383 	mov	a,r7
      00081A B5 05 09         [24] 2384 	cjne	a,ar5,00103$
                                   2385 ;	Matrix_Button.h:65: current_btn_matrix = Get_BTN_MATRIX();
      00081D 12r07rBD         [24] 2386 	lcall	_Get_BTN_MATRIX
      000820 AE 82            [24] 2387 	mov	r6, dpl
      000822 AF 83            [24] 2388 	mov	r7, dph
      000824 80 E0            [24] 2389 	sjmp	00101$
      000826                       2390 00103$:
                                   2391 ;	Matrix_Button.h:67: return BTN_MATRIX;
      000826 85*20 82         [24] 2392 	mov	dpl, _BTN_MATRIX
      000829 85*21 83         [24] 2393 	mov	dph, (_BTN_MATRIX + 1)
                                   2394 ;	Matrix_Button.h:68: }
      00082C 22               [24] 2395 	ret
                                   2396 ;------------------------------------------------------------
                                   2397 ;Allocation info for local variables in function 'new_dataframe'
                                   2398 ;------------------------------------------------------------
                                   2399 ;	IR_Reading.h:64: uint8 new_dataframe(){
                                   2400 ;	-----------------------------------------
                                   2401 ;	 function new_dataframe
                                   2402 ;	-----------------------------------------
      00082D                       2403 _new_dataframe:
                                   2404 ;	IR_Reading.h:65: return (data_frame!=0)?1:0;
      00082D E5*22            [12] 2405 	mov	a,_data_frame
      00082F 45*23            [12] 2406 	orl	a,(_data_frame + 1)
      000831 60 04            [24] 2407 	jz	00103$
      000833 7F 01            [12] 2408 	mov	r7,#0x01
      000835 80 02            [24] 2409 	sjmp	00104$
      000837                       2410 00103$:
      000837 7F 00            [12] 2411 	mov	r7,#0x00
      000839                       2412 00104$:
      000839 8F 82            [24] 2413 	mov	dpl,r7
                                   2414 ;	IR_Reading.h:66: }
      00083B 22               [24] 2415 	ret
                                   2416 ;------------------------------------------------------------
                                   2417 ;Allocation info for local variables in function 'read_extracted_frame'
                                   2418 ;------------------------------------------------------------
                                   2419 ;frame         Allocated to registers 
                                   2420 ;------------------------------------------------------------
                                   2421 ;	IR_Reading.h:69: uint32 read_extracted_frame(){
                                   2422 ;	-----------------------------------------
                                   2423 ;	 function read_extracted_frame
                                   2424 ;	-----------------------------------------
      00083C                       2425 _read_extracted_frame:
                                   2426 ;	IR_Reading.h:70: uint32 frame = data_frame;
      00083C 85*22 82         [24] 2427 	mov	dpl,_data_frame
      00083F 85*23 83         [24] 2428 	mov	dph,(_data_frame + 1)
                                   2429 ;	IR_Reading.h:71: data_frame = 0;
      000842 E4               [12] 2430 	clr	a
      000843 F5*22            [12] 2431 	mov	_data_frame,a
      000845 F5*23            [12] 2432 	mov	(_data_frame + 1),a
                                   2433 ;	IR_Reading.h:72: return frame;
                                   2434 ;	IR_Reading.h:73: }
      000847 22               [24] 2435 	ret
                                   2436 ;------------------------------------------------------------
                                   2437 ;Allocation info for local variables in function 'IR_Reading_Initial'
                                   2438 ;------------------------------------------------------------
                                   2439 ;	IR_Reading.h:75: void IR_Reading_Initial(){
                                   2440 ;	-----------------------------------------
                                   2441 ;	 function IR_Reading_Initial
                                   2442 ;	-----------------------------------------
      000848                       2443 _IR_Reading_Initial:
                                   2444 ;	IR_Reading.h:78: buffer = 0;
      000848 E4               [12] 2445 	clr	a
      000849 F5*24            [12] 2446 	mov	_buffer,a
      00084B F5*25            [12] 2447 	mov	(_buffer + 1),a
                                   2448 ;	IR_Reading.h:79: data_frame = 0;
      00084D F5*22            [12] 2449 	mov	_data_frame,a
      00084F F5*23            [12] 2450 	mov	(_data_frame + 1),a
                                   2451 ;	IR_Reading.h:80: negedge_count = 0;
      000851 F5*27            [12] 2452 	mov	_negedge_count,a
                                   2453 ;	IR_Reading.h:81: GLOBAL_INT(ENABLE);
      000853 75 82 01         [24] 2454 	mov	dpl, #0x01
      000856 12r00r8C         [24] 2455 	lcall	_GLOBAL_INT
                                   2456 ;	IR_Reading.h:82: eINT0_CTL(ENABLE);
      000859 75 82 01         [24] 2457 	mov	dpl, #0x01
      00085C 12r00r3A         [24] 2458 	lcall	_eINT0_CTL
                                   2459 ;	IR_Reading.h:83: TIMER0_CTL(ENABLE);
      00085F 75 82 01         [24] 2460 	mov	dpl, #0x01
      000862 12r00r5C         [24] 2461 	lcall	_TIMER0_CTL
                                   2462 ;	IR_Reading.h:84: TIMER0_CTL(MODE_16BIT);
      000865 75 82 04         [24] 2463 	mov	dpl, #0x04
      000868 12r00r5C         [24] 2464 	lcall	_TIMER0_CTL
                                   2465 ;	IR_Reading.h:85: TIMER0_CTL(START);
      00086B 75 82 02         [24] 2466 	mov	dpl, #0x02
      00086E 12r00r5C         [24] 2467 	lcall	_TIMER0_CTL
                                   2468 ;	IR_Reading.h:86: TIMER0_CTL(RESET);
      000871 75 82 05         [24] 2469 	mov	dpl, #0x05
                                   2470 ;	IR_Reading.h:87: }
      000874 02r00r5C         [24] 2471 	ljmp	_TIMER0_CTL
                                   2472 ;------------------------------------------------------------
                                   2473 ;Allocation info for local variables in function 'Timer0_OverFlow_Interrupt'
                                   2474 ;------------------------------------------------------------
                                   2475 ;	IR_Reading.h:89: void Timer0_OverFlow_Interrupt() __interrupt(1) {
                                   2476 ;	-----------------------------------------
                                   2477 ;	 function Timer0_OverFlow_Interrupt
                                   2478 ;	-----------------------------------------
      000877                       2479 _Timer0_OverFlow_Interrupt:
      000877 C0*00            [24] 2480 	push	bits
      000879 C0 E0            [24] 2481 	push	acc
      00087B C0 F0            [24] 2482 	push	b
      00087D C0 82            [24] 2483 	push	dpl
      00087F C0 83            [24] 2484 	push	dph
      000881 C0 07            [24] 2485 	push	(0+7)
      000883 C0 06            [24] 2486 	push	(0+6)
      000885 C0 05            [24] 2487 	push	(0+5)
      000887 C0 04            [24] 2488 	push	(0+4)
      000889 C0 03            [24] 2489 	push	(0+3)
      00088B C0 02            [24] 2490 	push	(0+2)
      00088D C0 01            [24] 2491 	push	(0+1)
      00088F C0 00            [24] 2492 	push	(0+0)
      000891 C0 D0            [24] 2493 	push	psw
      000893 75 D0 00         [24] 2494 	mov	psw,#0x00
                                   2495 ;	IR_Reading.h:91: TIMER0_CTL(RESET);
      000896 75 82 05         [24] 2496 	mov	dpl, #0x05
      000899 12r00r5C         [24] 2497 	lcall	_TIMER0_CTL
                                   2498 ;	IR_Reading.h:93: if(ms_count<67) ms_count = ms_count + 1;
      00089C 74 BD            [12] 2499 	mov	a,#0x100 - 0x43
      00089E 25*26            [12] 2500 	add	a,_ms_count
      0008A0 40 05            [24] 2501 	jc	00103$
      0008A2 E5*26            [12] 2502 	mov	a,_ms_count
      0008A4 04               [12] 2503 	inc	a
      0008A5 F5*26            [12] 2504 	mov	_ms_count,a
      0008A7                       2505 00103$:
                                   2506 ;	IR_Reading.h:94: }
      0008A7 D0 D0            [24] 2507 	pop	psw
      0008A9 D0 00            [24] 2508 	pop	(0+0)
      0008AB D0 01            [24] 2509 	pop	(0+1)
      0008AD D0 02            [24] 2510 	pop	(0+2)
      0008AF D0 03            [24] 2511 	pop	(0+3)
      0008B1 D0 04            [24] 2512 	pop	(0+4)
      0008B3 D0 05            [24] 2513 	pop	(0+5)
      0008B5 D0 06            [24] 2514 	pop	(0+6)
      0008B7 D0 07            [24] 2515 	pop	(0+7)
      0008B9 D0 83            [24] 2516 	pop	dph
      0008BB D0 82            [24] 2517 	pop	dpl
      0008BD D0 F0            [24] 2518 	pop	b
      0008BF D0 E0            [24] 2519 	pop	acc
      0008C1 D0*00            [24] 2520 	pop	bits
      0008C3 32               [24] 2521 	reti
                                   2522 ;------------------------------------------------------------
                                   2523 ;Allocation info for local variables in function 'External0_Interrupt'
                                   2524 ;------------------------------------------------------------
                                   2525 ;current_mscount Allocated to registers r7 
                                   2526 ;------------------------------------------------------------
                                   2527 ;	IR_Reading.h:96: void External0_Interrupt() __interrupt(0) {
                                   2528 ;	-----------------------------------------
                                   2529 ;	 function External0_Interrupt
                                   2530 ;	-----------------------------------------
      0008C4                       2531 _External0_Interrupt:
      0008C4 C0*00            [24] 2532 	push	bits
      0008C6 C0 E0            [24] 2533 	push	acc
      0008C8 C0 F0            [24] 2534 	push	b
      0008CA C0 82            [24] 2535 	push	dpl
      0008CC C0 83            [24] 2536 	push	dph
      0008CE C0 07            [24] 2537 	push	(0+7)
      0008D0 C0 06            [24] 2538 	push	(0+6)
      0008D2 C0 05            [24] 2539 	push	(0+5)
      0008D4 C0 04            [24] 2540 	push	(0+4)
      0008D6 C0 03            [24] 2541 	push	(0+3)
      0008D8 C0 02            [24] 2542 	push	(0+2)
      0008DA C0 01            [24] 2543 	push	(0+1)
      0008DC C0 00            [24] 2544 	push	(0+0)
      0008DE C0 D0            [24] 2545 	push	psw
      0008E0 75 D0 00         [24] 2546 	mov	psw,#0x00
                                   2547 ;	IR_Reading.h:99: current_mscount = ms_count;
      0008E3 AF*26            [24] 2548 	mov	r7,_ms_count
                                   2549 ;	IR_Reading.h:100: TIMER0_CTL(RESET);
      0008E5 75 82 05         [24] 2550 	mov	dpl, #0x05
      0008E8 C0 07            [24] 2551 	push	ar7
      0008EA 12r00r5C         [24] 2552 	lcall	_TIMER0_CTL
      0008ED D0 07            [24] 2553 	pop	ar7
                                   2554 ;	IR_Reading.h:101: ms_count=0;
      0008EF 75*26 00         [24] 2555 	mov	_ms_count,#0x00
                                   2556 ;	IR_Reading.h:102: negedge_count +=1;
      0008F2 E5*27            [12] 2557 	mov	a,_negedge_count
      0008F4 FE               [12] 2558 	mov	r6,a
      0008F5 04               [12] 2559 	inc	a
      0008F6 F5*27            [12] 2560 	mov	_negedge_count,a
                                   2561 ;	IR_Reading.h:105: if(current_mscount >= 67){
      0008F8 BF 43 00         [24] 2562 	cjne	r7,#0x43,00139$
      0008FB                       2563 00139$:
      0008FB 40 0A            [24] 2564 	jc	00109$
                                   2565 ;	IR_Reading.h:106: negedge_count = -2;
      0008FD 75*27 FE         [24] 2566 	mov	_negedge_count,#0xfe
                                   2567 ;	IR_Reading.h:107: RESET_BUFFER();
      000900 E4               [12] 2568 	clr	a
      000901 F5*24            [12] 2569 	mov	_buffer,a
      000903 F5*25            [12] 2570 	mov	(_buffer + 1),a
                                   2571 ;	IR_Reading.h:111: if(0 <= negedge_count && negedge_count <= 31){
      000905 80 48            [24] 2572 	sjmp	00113$
      000907                       2573 00109$:
      000907 E5*27            [12] 2574 	mov	a,_negedge_count
      000909 24 E0            [12] 2575 	add	a,#0xff - 0x1f
      00090B 40 25            [24] 2576 	jc	00107$
                                   2577 ;	IR_Reading.h:112: if( current_mscount >= 2){
      00090D BF 02 00         [24] 2578 	cjne	r7,#0x02,00142$
      000910                       2579 00142$:
      000910 40 3D            [24] 2580 	jc	00113$
                                   2581 ;	IR_Reading.h:113: PUSH_BIT_1();
      000912 74 1F            [12] 2582 	mov	a,#0x1f
      000914 C3               [12] 2583 	clr	c
      000915 95*27            [12] 2584 	subb	a,_negedge_count
      000917 F5 F0            [12] 2585 	mov	b, a
      000919 05 F0            [12] 2586 	inc	b
      00091B 7F 01            [12] 2587 	mov	r7,#0x01
      00091D 7E 00            [12] 2588 	mov	r6,#0x00
      00091F 80 06            [24] 2589 	sjmp	00145$
      000921                       2590 00144$:
      000921 EF               [12] 2591 	mov	a,r7
      000922 2F               [12] 2592 	add	a,r7
      000923 FF               [12] 2593 	mov	r7,a
      000924 EE               [12] 2594 	mov	a,r6
      000925 33               [12] 2595 	rlc	a
      000926 FE               [12] 2596 	mov	r6,a
      000927                       2597 00145$:
      000927 D5 F0 F7         [24] 2598 	djnz	b,00144$
      00092A EF               [12] 2599 	mov	a,r7
      00092B 42*24            [12] 2600 	orl	_buffer,a
      00092D EE               [12] 2601 	mov	a,r6
      00092E 42*25            [12] 2602 	orl	(_buffer + 1),a
                                   2603 ;	IR_Reading.h:115: PUSH_BIT_0();
      000930 80 1D            [24] 2604 	sjmp	00113$
      000932                       2605 00107$:
                                   2606 ;	IR_Reading.h:117: }else if(negedge_count >= 32){
      000932 74 E0            [12] 2607 	mov	a,#0x100 - 0x20
      000934 25*27            [12] 2608 	add	a,_negedge_count
      000936 50 17            [24] 2609 	jnc	00113$
                                   2610 ;	IR_Reading.h:118: EXTRACT_FRAME();
      000938 85*24*22         [24] 2611 	mov	_data_frame,_buffer
      00093B 85*25*23         [24] 2612 	mov	(_data_frame + 1),(_buffer + 1)
      00093E E4               [12] 2613 	clr	a
      00093F F5*24            [12] 2614 	mov	_buffer,a
      000941 F5*25            [12] 2615 	mov	(_buffer + 1),a
      000943 F5*27            [12] 2616 	mov	_negedge_count,a
                                   2617 ;	IR_Reading.h:119: FrameExtracted_LED=0;
                                   2618 ;	assignBit
      000945 C2 A0            [12] 2619 	clr	_FrameExtracted_LED
                                   2620 ;	IR_Reading.h:120: delay_ms(1);
      000947 90 00 01         [24] 2621 	mov	dptr,#0x0001
      00094A 12r00r17         [24] 2622 	lcall	_delay_ms
                                   2623 ;	IR_Reading.h:121: FrameExtracted_LED=1;
                                   2624 ;	assignBit
      00094D D2 A0            [12] 2625 	setb	_FrameExtracted_LED
      00094F                       2626 00113$:
                                   2627 ;	IR_Reading.h:124: }
      00094F D0 D0            [24] 2628 	pop	psw
      000951 D0 00            [24] 2629 	pop	(0+0)
      000953 D0 01            [24] 2630 	pop	(0+1)
      000955 D0 02            [24] 2631 	pop	(0+2)
      000957 D0 03            [24] 2632 	pop	(0+3)
      000959 D0 04            [24] 2633 	pop	(0+4)
      00095B D0 05            [24] 2634 	pop	(0+5)
      00095D D0 06            [24] 2635 	pop	(0+6)
      00095F D0 07            [24] 2636 	pop	(0+7)
      000961 D0 83            [24] 2637 	pop	dph
      000963 D0 82            [24] 2638 	pop	dpl
      000965 D0 F0            [24] 2639 	pop	b
      000967 D0 E0            [24] 2640 	pop	acc
      000969 D0*00            [24] 2641 	pop	bits
      00096B 02r00r00         [24] 2642 	ljmp	sdcc_atomic_maybe_rollback
                                   2643 ;------------------------------------------------------------
                                   2644 ;Allocation info for local variables in function 'CODE2NUM'
                                   2645 ;------------------------------------------------------------
                                   2646 ;CODE          Allocated to registers 
                                   2647 ;------------------------------------------------------------
                                   2648 ;	main.h:36: uint8 CODE2NUM(uint32 CODE){
                                   2649 ;	-----------------------------------------
                                   2650 ;	 function CODE2NUM
                                   2651 ;	-----------------------------------------
      00096E                       2652 _CODE2NUM:
                                   2653 ;	main.h:49: return 0;
      00096E 75 82 00         [24] 2654 	mov	dpl, #0x00
                                   2655 ;	main.h:50: }
      000971 22               [24] 2656 	ret
                                   2657 ;------------------------------------------------------------
                                   2658 ;Allocation info for local variables in function 'YES_NO'
                                   2659 ;------------------------------------------------------------
                                   2660 ;CODE          Allocated to registers r6 r7 
                                   2661 ;------------------------------------------------------------
                                   2662 ;	main.h:52: uint8 YES_NO(){
                                   2663 ;	-----------------------------------------
                                   2664 ;	 function YES_NO
                                   2665 ;	-----------------------------------------
      000972                       2666 _YES_NO:
                                   2667 ;	main.h:54: LED[5] = 0; LED[4] = 0;
      000972 75*1D 00         [24] 2668 	mov	(_LED + 0x0005),#0x00
      000975 75*1C 00         [24] 2669 	mov	(_LED + 0x0004),#0x00
                                   2670 ;	main.h:55: LED[3] = 0; LED[2] = 0;
      000978 75*1B 00         [24] 2671 	mov	(_LED + 0x0003),#0x00
      00097B 75*1A 00         [24] 2672 	mov	(_LED + 0x0002),#0x00
                                   2673 ;	main.h:56: LED[1] = 0; LED[0] = 0;
      00097E 75*19 00         [24] 2674 	mov	(_LED + 0x0001),#0x00
      000981 75*18 00         [24] 2675 	mov	_LED,#0x00
                                   2676 ;	main.h:57: while(0x1){
      000984                       2677 00106$:
                                   2678 ;	main.h:58: CODE = read_extracted_frame();
      000984 12r08r3C         [24] 2679 	lcall	_read_extracted_frame
      000987 AE 82            [24] 2680 	mov	r6, dpl
      000989 AF 83            [24] 2681 	mov	r7, dph
                                   2682 ;	main.h:59: LED[7] = 0x6E; LED[6] = 0x37;
      00098B 75*1F 6E         [24] 2683 	mov	(_LED + 0x0007),#0x6e
      00098E 75*1E 37         [24] 2684 	mov	(_LED + 0x0006),#0x37
                                   2685 ;	main.h:60: Disp8leds7seg(1);
      000991 90 00 01         [24] 2686 	mov	dptr,#0x0001
      000994 C0 07            [24] 2687 	push	ar7
      000996 C0 06            [24] 2688 	push	ar6
      000998 12r07r08         [24] 2689 	lcall	_Disp8leds7seg
      00099B D0 06            [24] 2690 	pop	ar6
      00099D D0 07            [24] 2691 	pop	ar7
                                   2692 ;	main.h:61: switch (CODE) {
      00099F BE DD 05         [24] 2693 	cjne	r6,#0xdd,00134$
      0009A2 BF 22 02         [24] 2694 	cjne	r7,#0x22,00134$
      0009A5 80 10            [24] 2695 	sjmp	00101$
      0009A7                       2696 00134$:
      0009A7 BE 9D 05         [24] 2697 	cjne	r6,#0x9d,00135$
      0009AA BF 62 02         [24] 2698 	cjne	r7,#0x62,00135$
      0009AD 80 0C            [24] 2699 	sjmp	00102$
      0009AF                       2700 00135$:
                                   2701 ;	main.h:63: case PLAY_PAUSE: return 1;
      0009AF BE 5D D2         [24] 2702 	cjne	r6,#0x5d,00106$
      0009B2 BF A2 CF         [24] 2703 	cjne	r7,#0xa2,00106$
      0009B5 80 08            [24] 2704 	sjmp	00103$
      0009B7                       2705 00101$:
      0009B7 75 82 01         [24] 2706 	mov	dpl, #0x01
                                   2707 ;	main.h:64: case MODE: return 0;
      0009BA 22               [24] 2708 	ret
      0009BB                       2709 00102$:
      0009BB 75 82 00         [24] 2710 	mov	dpl, #0x00
                                   2711 ;	main.h:65: case ON_OFF: return 0;
      0009BE 22               [24] 2712 	ret
      0009BF                       2713 00103$:
      0009BF 75 82 00         [24] 2714 	mov	dpl, #0x00
                                   2715 ;	main.h:68: return 0;
                                   2716 ;	main.h:69: }
      0009C2 22               [24] 2717 	ret
                                   2718 ;------------------------------------------------------------
                                   2719 ;Allocation info for local variables in function 'SET_TIMER'
                                   2720 ;------------------------------------------------------------
                                   2721 ;t             Allocated with name '_SET_TIMER_t_10000_99'
                                   2722 ;POS           Allocated to registers r4 
                                   2723 ;CODE          Allocated to registers r2 r3 
                                   2724 ;tmp           Allocated with name '_SET_TIMER_tmp_10000_100'
                                   2725 ;------------------------------------------------------------
                                   2726 ;	main.h:71: uint8 SET_TIMER(TIME* t){
                                   2727 ;	-----------------------------------------
                                   2728 ;	 function SET_TIMER
                                   2729 ;	-----------------------------------------
      0009C3                       2730 _SET_TIMER:
      0009C3 85 82*40         [24] 2731 	mov	_SET_TIMER_t_10000_99,dpl
      0009C6 85 83*41         [24] 2732 	mov	(_SET_TIMER_t_10000_99 + 1),dph
      0009C9 85 F0*42         [24] 2733 	mov	(_SET_TIMER_t_10000_99 + 2),b
                                   2734 ;	main.h:72: uint8 POS = 0;
      0009CC 7C 00            [12] 2735 	mov	r4,#0x00
                                   2736 ;	main.h:81: ds1302_read_time(&tmp, 0x7);
      0009CE 75*12 07         [24] 2737 	mov	_ds1302_read_time_PARM_2,#0x07
      0009D1 90r00r43         [24] 2738 	mov	dptr,#_SET_TIMER_tmp_10000_100
      0009D4 75 F0 40         [24] 2739 	mov	b, #0x40
      0009D7 C0 04            [24] 2740 	push	ar4
      0009D9 12r02r1D         [24] 2741 	lcall	_ds1302_read_time
      0009DC D0 04            [24] 2742 	pop	ar4
                                   2743 ;	main.h:82: while(0x1){
      0009DE                       2744 00115$:
                                   2745 ;	main.h:83: CODE = read_extracted_frame();
      0009DE C0 04            [24] 2746 	push	ar4
      0009E0 12r08r3C         [24] 2747 	lcall	_read_extracted_frame
      0009E3 AA 82            [24] 2748 	mov	r2, dpl
      0009E5 AB 83            [24] 2749 	mov	r3, dph
      0009E7 D0 04            [24] 2750 	pop	ar4
                                   2751 ;	main.h:84: if(CODE == PLAY_PAUSE) break;
      0009E9 BA DD 06         [24] 2752 	cjne	r2,#0xdd,00191$
      0009EC BB 22 03         [24] 2753 	cjne	r3,#0x22,00191$
      0009EF 02r0ArE6         [24] 2754 	ljmp	00116$
      0009F2                       2755 00191$:
                                   2756 ;	main.h:85: if(CODE == PREV) POS = (POS+1 + 2)%2;
      0009F2 BA FD 0B         [24] 2757 	cjne	r2,#0xfd,00104$
      0009F5 BB 02 08         [24] 2758 	cjne	r3,#0x02,00104$
      0009F8 8C 07            [24] 2759 	mov	ar7,r4
      0009FA 74 03            [12] 2760 	mov	a,#0x03
      0009FC 2F               [12] 2761 	add	a, r7
      0009FD 54 01            [12] 2762 	anl	a,#0x01
      0009FF FC               [12] 2763 	mov	r4,a
      000A00                       2764 00104$:
                                   2765 ;	main.h:86: if(CODE == NEXT) POS = (POS-1 + 2)%2;
      000A00 BA 3D 0A         [24] 2766 	cjne	r2,#0x3d,00106$
      000A03 BB C2 07         [24] 2767 	cjne	r3,#0xc2,00106$
      000A06 8C 07            [24] 2768 	mov	ar7,r4
      000A08 EF               [12] 2769 	mov	a,r7
      000A09 04               [12] 2770 	inc	a
      000A0A 54 01            [12] 2771 	anl	a,#0x01
      000A0C FC               [12] 2772 	mov	r4,a
      000A0D                       2773 00106$:
                                   2774 ;	main.h:87: if(CODE == ON_OFF) return 0;
      000A0D BA 5D 07         [24] 2775 	cjne	r2,#0x5d,00108$
      000A10 BB A2 04         [24] 2776 	cjne	r3,#0xa2,00108$
      000A13 75 82 00         [24] 2777 	mov	dpl, #0x00
      000A16 22               [24] 2778 	ret
      000A17                       2779 00108$:
                                   2780 ;	main.h:88: if(CODE == MODE) return 0;
      000A17 BA 9D 07         [24] 2781 	cjne	r2,#0x9d,00110$
      000A1A BB 62 04         [24] 2782 	cjne	r3,#0x62,00110$
      000A1D 75 82 00         [24] 2783 	mov	dpl, #0x00
      000A20 22               [24] 2784 	ret
      000A21                       2785 00110$:
                                   2786 ;	main.h:89: switch (POS) {
      000A21 BC 00 02         [24] 2787 	cjne	r4,#0x00,00200$
      000A24 80 05            [24] 2788 	sjmp	00111$
      000A26                       2789 00200$:
                                   2790 ;	main.h:90: case 0:
      000A26 BC 01 4D         [24] 2791 	cjne	r4,#0x01,00113$
      000A29 80 2A            [24] 2792 	sjmp	00112$
      000A2B                       2793 00111$:
                                   2794 ;	main.h:91: tmp.MINUTE += CODE2NUM(CODE)%10; tmp.MINUTE%=60; break;
      000A2B AF*48            [24] 2795 	mov	r7,(_SET_TIMER_tmp_10000_100 + 0x0005)
      000A2D 8A 82            [24] 2796 	mov	dpl, r2
      000A2F 8B 83            [24] 2797 	mov	dph, r3
      000A31 C0 07            [24] 2798 	push	ar7
      000A33 C0 04            [24] 2799 	push	ar4
      000A35 12r09r6E         [24] 2800 	lcall	_CODE2NUM
      000A38 AE 82            [24] 2801 	mov	r6, dpl
      000A3A D0 04            [24] 2802 	pop	ar4
      000A3C D0 07            [24] 2803 	pop	ar7
      000A3E 75 F0 0A         [24] 2804 	mov	b,#0x0a
      000A41 EE               [12] 2805 	mov	a,r6
      000A42 84               [48] 2806 	div	ab
      000A43 E5 F0            [12] 2807 	mov	a,b
      000A45 2F               [12] 2808 	add	a, r7
      000A46 F5*48            [12] 2809 	mov	(_SET_TIMER_tmp_10000_100 + 0x0005),a
      000A48 AF*48            [24] 2810 	mov	r7,(_SET_TIMER_tmp_10000_100 + 0x0005)
      000A4A 75 F0 3C         [24] 2811 	mov	b,#0x3c
      000A4D EF               [12] 2812 	mov	a,r7
      000A4E 84               [48] 2813 	div	ab
      000A4F AF F0            [24] 2814 	mov	r7,b
      000A51 8F*48            [24] 2815 	mov	(_SET_TIMER_tmp_10000_100 + 0x0005),r7
                                   2816 ;	main.h:92: case 1:
      000A53 80 21            [24] 2817 	sjmp	00113$
      000A55                       2818 00112$:
                                   2819 ;	main.h:93: tmp.HOUR   += CODE2NUM(CODE); tmp.HOUR%=24; break;
      000A55 AF*47            [24] 2820 	mov	r7,(_SET_TIMER_tmp_10000_100 + 0x0004)
      000A57 8A 82            [24] 2821 	mov	dpl, r2
      000A59 8B 83            [24] 2822 	mov	dph, r3
      000A5B C0 07            [24] 2823 	push	ar7
      000A5D C0 04            [24] 2824 	push	ar4
      000A5F 12r09r6E         [24] 2825 	lcall	_CODE2NUM
      000A62 AE 82            [24] 2826 	mov	r6, dpl
      000A64 D0 04            [24] 2827 	pop	ar4
      000A66 D0 07            [24] 2828 	pop	ar7
      000A68 EE               [12] 2829 	mov	a,r6
      000A69 2F               [12] 2830 	add	a, r7
      000A6A FF               [12] 2831 	mov	r7,a
      000A6B 8F*47            [24] 2832 	mov	(_SET_TIMER_tmp_10000_100 + 0x0004),r7
      000A6D 75 F0 18         [24] 2833 	mov	b,#0x18
      000A70 EF               [12] 2834 	mov	a,r7
      000A71 84               [48] 2835 	div	ab
      000A72 AF F0            [24] 2836 	mov	r7,b
      000A74 8F*47            [24] 2837 	mov	(_SET_TIMER_tmp_10000_100 + 0x0004),r7
                                   2838 ;	main.h:94: }
      000A76                       2839 00113$:
                                   2840 ;	main.h:95: LED[0] = DIGIT_CODE[tmp.MINUTE%10] + ((POS==0)?(0x80):(0));
      000A76 AF*48            [24] 2841 	mov	r7,(_SET_TIMER_tmp_10000_100 + 0x0005)
      000A78 75 F0 0A         [24] 2842 	mov	b,#0x0a
      000A7B EF               [12] 2843 	mov	a,r7
      000A7C 84               [48] 2844 	div	ab
      000A7D AF F0            [24] 2845 	mov	r7,b
      000A7F 7E 00            [12] 2846 	mov	r6,#0x00
      000A81 EF               [12] 2847 	mov	a,r7
      000A82 24r00            [12] 2848 	add	a, #_DIGIT_CODE
      000A84 F5 82            [12] 2849 	mov	dpl,a
      000A86 EE               [12] 2850 	mov	a,r6
      000A87 34s00            [12] 2851 	addc	a, #(_DIGIT_CODE >> 8)
      000A89 F5 83            [12] 2852 	mov	dph,a
      000A8B E4               [12] 2853 	clr	a
      000A8C 93               [24] 2854 	movc	a,@a+dptr
      000A8D FF               [12] 2855 	mov	r7,a
      000A8E EC               [12] 2856 	mov	a,r4
      000A8F 70 04            [24] 2857 	jnz	00121$
      000A91 7E 80            [12] 2858 	mov	r6,#0x80
      000A93 80 02            [24] 2859 	sjmp	00122$
      000A95                       2860 00121$:
      000A95 7E 00            [12] 2861 	mov	r6,#0x00
      000A97                       2862 00122$:
      000A97 EE               [12] 2863 	mov	a,r6
      000A98 2F               [12] 2864 	add	a, r7
      000A99 F5*18            [12] 2865 	mov	_LED,a
                                   2866 ;	main.h:96: LED[1] = DIGIT_CODE[tmp.MINUTE/10];
      000A9B AF*48            [24] 2867 	mov	r7,(_SET_TIMER_tmp_10000_100 + 0x0005)
      000A9D 75 F0 0A         [24] 2868 	mov	b,#0x0a
      000AA0 EF               [12] 2869 	mov	a,r7
      000AA1 84               [48] 2870 	div	ab
      000AA2 7E 00            [12] 2871 	mov	r6,#0x00
      000AA4 90r00r00         [24] 2872 	mov	dptr,#_DIGIT_CODE
      000AA7 93               [24] 2873 	movc	a,@a+dptr
      000AA8 F5*19            [12] 2874 	mov	(_LED + 0x0001), a
                                   2875 ;	main.h:97: LED[2] = DIGIT_CODE[tmp.HOUR%10]   + ((POS==1)?(0x80):(0));
      000AAA AF*47            [24] 2876 	mov	r7,(_SET_TIMER_tmp_10000_100 + 0x0004)
      000AAC 75 F0 0A         [24] 2877 	mov	b,#0x0a
      000AAF EF               [12] 2878 	mov	a,r7
      000AB0 84               [48] 2879 	div	ab
      000AB1 E5 F0            [12] 2880 	mov	a,b
      000AB3 24r00            [12] 2881 	add	a, #_DIGIT_CODE
      000AB5 F5 82            [12] 2882 	mov	dpl,a
      000AB7 EE               [12] 2883 	mov	a,r6
      000AB8 34s00            [12] 2884 	addc	a, #(_DIGIT_CODE >> 8)
      000ABA F5 83            [12] 2885 	mov	dph,a
      000ABC E4               [12] 2886 	clr	a
      000ABD 93               [24] 2887 	movc	a,@a+dptr
      000ABE FF               [12] 2888 	mov	r7,a
      000ABF BC 01 04         [24] 2889 	cjne	r4,#0x01,00123$
      000AC2 7E 80            [12] 2890 	mov	r6,#0x80
      000AC4 80 02            [24] 2891 	sjmp	00124$
      000AC6                       2892 00123$:
      000AC6 7E 00            [12] 2893 	mov	r6,#0x00
      000AC8                       2894 00124$:
      000AC8 EE               [12] 2895 	mov	a,r6
      000AC9 2F               [12] 2896 	add	a, r7
      000ACA F5*1A            [12] 2897 	mov	(_LED + 0x0002),a
                                   2898 ;	main.h:98: LED[3] = DIGIT_CODE[tmp.HOUR/10];
      000ACC AF*47            [24] 2899 	mov	r7,(_SET_TIMER_tmp_10000_100 + 0x0004)
      000ACE 75 F0 0A         [24] 2900 	mov	b,#0x0a
      000AD1 EF               [12] 2901 	mov	a,r7
      000AD2 84               [48] 2902 	div	ab
      000AD3 90r00r00         [24] 2903 	mov	dptr,#_DIGIT_CODE
      000AD6 93               [24] 2904 	movc	a,@a+dptr
      000AD7 F5*1B            [12] 2905 	mov	(_LED + 0x0003), a
                                   2906 ;	main.h:99: Disp8leds7seg(50);
      000AD9 90 00 32         [24] 2907 	mov	dptr,#0x0032
      000ADC C0 04            [24] 2908 	push	ar4
      000ADE 12r07r08         [24] 2909 	lcall	_Disp8leds7seg
      000AE1 D0 04            [24] 2910 	pop	ar4
      000AE3 02r09rDE         [24] 2911 	ljmp	00115$
      000AE6                       2912 00116$:
                                   2913 ;	main.h:101: if(YES_NO()){
      000AE6 12r09r72         [24] 2914 	lcall	_YES_NO
      000AE9 E5 82            [12] 2915 	mov	a, dpl
      000AEB 60 22            [24] 2916 	jz	00118$
                                   2917 ;	main.h:102: *t = tmp;
      000AED AD*40            [24] 2918 	mov	r5,_SET_TIMER_t_10000_99
      000AEF AE*41            [24] 2919 	mov	r6,(_SET_TIMER_t_10000_99 + 1)
      000AF1 AF*42            [24] 2920 	mov	r7,(_SET_TIMER_t_10000_99 + 2)
      000AF3 75*00r43         [24] 2921 	mov	___memcpy_PARM_2,#_SET_TIMER_tmp_10000_100
      000AF6 75*01 00         [24] 2922 	mov	(___memcpy_PARM_2 + 1),#0x00
      000AF9 75*02 40         [24] 2923 	mov	(___memcpy_PARM_2 + 2),#0x40
      000AFC 75*00 07         [24] 2924 	mov	___memcpy_PARM_3,#0x07
      000AFF 75*01 00         [24] 2925 	mov	(___memcpy_PARM_3 + 1),#0x00
      000B02 8D 82            [24] 2926 	mov	dpl, r5
      000B04 8E 83            [24] 2927 	mov	dph, r6
      000B06 8F F0            [24] 2928 	mov	b, r7
      000B08 12r00r00         [24] 2929 	lcall	___memcpy
                                   2930 ;	main.h:103: return 1;
      000B0B 75 82 01         [24] 2931 	mov	dpl, #0x01
      000B0E 22               [24] 2932 	ret
      000B0F                       2933 00118$:
                                   2934 ;	main.h:105: return 0;
      000B0F 75 82 00         [24] 2935 	mov	dpl, #0x00
                                   2936 ;	main.h:106: }
      000B12 22               [24] 2937 	ret
                                   2938 ;------------------------------------------------------------
                                   2939 ;Allocation info for local variables in function 'SET_ON_OFF'
                                   2940 ;------------------------------------------------------------
                                   2941 ;dev           Allocated with name '_SET_ON_OFF_PARM_2'
                                   2942 ;val           Allocated with name '_SET_ON_OFF_val_10000_104'
                                   2943 ;tmp           Allocated to registers r4 
                                   2944 ;CODE          Allocated to registers r6 r7 
                                   2945 ;sloc0         Allocated with name '_SET_ON_OFF_sloc0_1_0'
                                   2946 ;------------------------------------------------------------
                                   2947 ;	main.h:108: uint8 SET_ON_OFF(uint8 *val, uint8 dev){
                                   2948 ;	-----------------------------------------
                                   2949 ;	 function SET_ON_OFF
                                   2950 ;	-----------------------------------------
      000B13                       2951 _SET_ON_OFF:
      000B13 85 82*4B         [24] 2952 	mov	_SET_ON_OFF_val_10000_104,dpl
      000B16 85 83*4C         [24] 2953 	mov	(_SET_ON_OFF_val_10000_104 + 1),dph
      000B19 85 F0*4D         [24] 2954 	mov	(_SET_ON_OFF_val_10000_104 + 2),b
                                   2955 ;	main.h:109: uint8 tmp = 0;
      000B1C 7C 00            [12] 2956 	mov	r4,#0x00
                                   2957 ;	main.h:111: while(0x1){
      000B1E E5*4A            [12] 2958 	mov	a,_SET_ON_OFF_PARM_2
      000B20 24r00            [12] 2959 	add	a, #_DIGIT_CODE
      000B22 FA               [12] 2960 	mov	r2,a
      000B23 E4               [12] 2961 	clr	a
      000B24 34s00            [12] 2962 	addc	a, #(_DIGIT_CODE >> 8)
      000B26 FB               [12] 2963 	mov	r3,a
      000B27 8A*4E            [24] 2964 	mov	_SET_ON_OFF_sloc0_1_0,r2
      000B29 8B*4F            [24] 2965 	mov	(_SET_ON_OFF_sloc0_1_0 + 1),r3
      000B2B                       2966 00115$:
                                   2967 ;	main.h:112: CODE = read_extracted_frame();
      000B2B C0 04            [24] 2968 	push	ar4
      000B2D C0 03            [24] 2969 	push	ar3
      000B2F C0 02            [24] 2970 	push	ar2
      000B31 12r08r3C         [24] 2971 	lcall	_read_extracted_frame
      000B34 AE 82            [24] 2972 	mov	r6, dpl
      000B36 AF 83            [24] 2973 	mov	r7, dph
      000B38 D0 02            [24] 2974 	pop	ar2
      000B3A D0 03            [24] 2975 	pop	ar3
      000B3C D0 04            [24] 2976 	pop	ar4
                                   2977 ;	main.h:113: if(CODE == PLAY_PAUSE) break;
      000B3E BE DD 06         [24] 2978 	cjne	r6,#0xdd,00175$
      000B41 BF 22 03         [24] 2979 	cjne	r7,#0x22,00175$
      000B44 02r0BrEB         [24] 2980 	ljmp	00116$
      000B47                       2981 00175$:
                                   2982 ;	main.h:114: if(CODE == PREV) tmp = (tmp+1 + 2)%2;
      000B47 BE FD 0B         [24] 2983 	cjne	r6,#0xfd,00104$
      000B4A BF 02 08         [24] 2984 	cjne	r7,#0x02,00104$
      000B4D 8C 05            [24] 2985 	mov	ar5,r4
      000B4F 74 03            [12] 2986 	mov	a,#0x03
      000B51 2D               [12] 2987 	add	a, r5
      000B52 54 01            [12] 2988 	anl	a,#0x01
      000B54 FC               [12] 2989 	mov	r4,a
      000B55                       2990 00104$:
                                   2991 ;	main.h:115: if(CODE == NEXT) tmp = (tmp-1 + 2)%2;
      000B55 BE 3D 0A         [24] 2992 	cjne	r6,#0x3d,00106$
      000B58 BF C2 07         [24] 2993 	cjne	r7,#0xc2,00106$
      000B5B 8C 05            [24] 2994 	mov	ar5,r4
      000B5D ED               [12] 2995 	mov	a,r5
      000B5E 04               [12] 2996 	inc	a
      000B5F 54 01            [12] 2997 	anl	a,#0x01
      000B61 FC               [12] 2998 	mov	r4,a
      000B62                       2999 00106$:
                                   3000 ;	main.h:116: if(CODE == ON_OFF) return 0;
      000B62 BE 5D 07         [24] 3001 	cjne	r6,#0x5d,00108$
      000B65 BF A2 04         [24] 3002 	cjne	r7,#0xa2,00108$
      000B68 75 82 00         [24] 3003 	mov	dpl, #0x00
      000B6B 22               [24] 3004 	ret
      000B6C                       3005 00108$:
                                   3006 ;	main.h:117: if(CODE == MODE) return 0;
      000B6C BE 9D 07         [24] 3007 	cjne	r6,#0x9d,00110$
      000B6F BF 62 04         [24] 3008 	cjne	r7,#0x62,00110$
      000B72 75 82 00         [24] 3009 	mov	dpl, #0x00
      000B75 22               [24] 3010 	ret
      000B76                       3011 00110$:
                                   3012 ;	main.h:118: switch (tmp) {
      000B76 BC 00 02         [24] 3013 	cjne	r4,#0x00,00184$
      000B79 80 05            [24] 3014 	sjmp	00111$
      000B7B                       3015 00184$:
                                   3016 ;	main.h:119: case 0:
      000B7B BC 01 58         [24] 3017 	cjne	r4,#0x01,00113$
      000B7E 80 29            [24] 3018 	sjmp	00112$
      000B80                       3019 00111$:
                                   3020 ;	main.h:120: LED[7] = DIGIT_CODE[13]; 
      000B80 90r00r0D         [24] 3021 	mov	dptr,#(_DIGIT_CODE + 0x000d)
      000B83 E4               [12] 3022 	clr	a
      000B84 93               [24] 3023 	movc	a,@a+dptr
      000B85 F5*1F            [12] 3024 	mov	(_LED + 0x0007), a
                                   3025 ;	main.h:121: LED[6] = DIGIT_CODE[dev]; 
      000B87 85*4E 82         [24] 3026 	mov	dpl,_SET_ON_OFF_sloc0_1_0
      000B8A 85*4F 83         [24] 3027 	mov	dph,(_SET_ON_OFF_sloc0_1_0 + 1)
      000B8D E4               [12] 3028 	clr	a
      000B8E 93               [24] 3029 	movc	a,@a+dptr
      000B8F F5*1E            [12] 3030 	mov	(_LED + 0x0006), a
                                   3031 ;	main.h:122: LED[5] = 0; 
      000B91 75*1D 00         [24] 3032 	mov	(_LED + 0x0005),#0x00
                                   3033 ;	main.h:123: LED[4] = 0;
      000B94 75*1C 00         [24] 3034 	mov	(_LED + 0x0004),#0x00
                                   3035 ;	main.h:124: LED[3] = DIGIT_CODE[0]; 
      000B97 90r00r00         [24] 3036 	mov	dptr,#_DIGIT_CODE
      000B9A E4               [12] 3037 	clr	a
      000B9B 93               [24] 3038 	movc	a,@a+dptr
      000B9C F5*1B            [12] 3039 	mov	(_LED + 0x0003), a
                                   3040 ;	main.h:125: LED[2] = 0x37;
      000B9E 75*1A 37         [24] 3041 	mov	(_LED + 0x0002),#0x37
                                   3042 ;	main.h:126: LED[1] = 0x0; 
      000BA1 75*19 00         [24] 3043 	mov	(_LED + 0x0001),#0x00
                                   3044 ;	main.h:127: LED[0] = 0x0;
      000BA4 75*18 00         [24] 3045 	mov	_LED,#0x00
                                   3046 ;	main.h:128: break;
                                   3047 ;	main.h:129: case 1:
      000BA7 80 2D            [24] 3048 	sjmp	00113$
      000BA9                       3049 00112$:
                                   3050 ;	main.h:130: LED[7] = DIGIT_CODE[13]; 
      000BA9 90r00r0D         [24] 3051 	mov	dptr,#(_DIGIT_CODE + 0x000d)
      000BAC E4               [12] 3052 	clr	a
      000BAD 93               [24] 3053 	movc	a,@a+dptr
      000BAE F5*1F            [12] 3054 	mov	(_LED + 0x0007), a
                                   3055 ;	main.h:131: LED[6] = DIGIT_CODE[dev]; 
      000BB0 8A 82            [24] 3056 	mov	dpl,r2
      000BB2 8B 83            [24] 3057 	mov	dph,r3
      000BB4 E4               [12] 3058 	clr	a
      000BB5 93               [24] 3059 	movc	a,@a+dptr
      000BB6 F5*1E            [12] 3060 	mov	(_LED + 0x0006), a
                                   3061 ;	main.h:132: LED[5] = 0; 
      000BB8 75*1D 00         [24] 3062 	mov	(_LED + 0x0005),#0x00
                                   3063 ;	main.h:133: LED[4] = 0;
      000BBB 75*1C 00         [24] 3064 	mov	(_LED + 0x0004),#0x00
                                   3065 ;	main.h:134: LED[3] = DIGIT_CODE[0]; 
      000BBE 90r00r00         [24] 3066 	mov	dptr,#_DIGIT_CODE
      000BC1 E4               [12] 3067 	clr	a
      000BC2 93               [24] 3068 	movc	a,@a+dptr
      000BC3 F5*1B            [12] 3069 	mov	(_LED + 0x0003), a
                                   3070 ;	main.h:135: LED[2] = DIGIT_CODE[15]; 
      000BC5 90r00r0F         [24] 3071 	mov	dptr,#(_DIGIT_CODE + 0x000f)
      000BC8 E4               [12] 3072 	clr	a
      000BC9 93               [24] 3073 	movc	a,@a+dptr
      000BCA F5*1A            [12] 3074 	mov	(_LED + 0x0002), a
                                   3075 ;	main.h:136: LED[1] = DIGIT_CODE[15]; 
      000BCC 90r00r0F         [24] 3076 	mov	dptr,#(_DIGIT_CODE + 0x000f)
      000BCF E4               [12] 3077 	clr	a
      000BD0 93               [24] 3078 	movc	a,@a+dptr
      000BD1 F5*19            [12] 3079 	mov	(_LED + 0x0001), a
                                   3080 ;	main.h:137: LED[0] = 0;
      000BD3 75*18 00         [24] 3081 	mov	_LED,#0x00
                                   3082 ;	main.h:139: }
      000BD6                       3083 00113$:
                                   3084 ;	main.h:140: Disp8leds7seg(50);
      000BD6 90 00 32         [24] 3085 	mov	dptr,#0x0032
      000BD9 C0 04            [24] 3086 	push	ar4
      000BDB C0 03            [24] 3087 	push	ar3
      000BDD C0 02            [24] 3088 	push	ar2
      000BDF 12r07r08         [24] 3089 	lcall	_Disp8leds7seg
      000BE2 D0 02            [24] 3090 	pop	ar2
      000BE4 D0 03            [24] 3091 	pop	ar3
      000BE6 D0 04            [24] 3092 	pop	ar4
      000BE8 02r0Br2B         [24] 3093 	ljmp	00115$
      000BEB                       3094 00116$:
                                   3095 ;	main.h:142: if(YES_NO()){
      000BEB C0 04            [24] 3096 	push	ar4
      000BED 12r09r72         [24] 3097 	lcall	_YES_NO
      000BF0 E5 82            [12] 3098 	mov	a, dpl
      000BF2 D0 04            [24] 3099 	pop	ar4
      000BF4 60 11            [24] 3100 	jz	00118$
                                   3101 ;	main.h:143: *val = tmp;
      000BF6 85*4B 82         [24] 3102 	mov	dpl,_SET_ON_OFF_val_10000_104
      000BF9 85*4C 83         [24] 3103 	mov	dph,(_SET_ON_OFF_val_10000_104 + 1)
      000BFC 85*4D F0         [24] 3104 	mov	b,(_SET_ON_OFF_val_10000_104 + 2)
      000BFF EC               [12] 3105 	mov	a,r4
      000C00 12r00r00         [24] 3106 	lcall	__gptrput
                                   3107 ;	main.h:144: return 1;
      000C03 75 82 01         [24] 3108 	mov	dpl, #0x01
      000C06 22               [24] 3109 	ret
      000C07                       3110 00118$:
                                   3111 ;	main.h:146: return 0;
      000C07 75 82 00         [24] 3112 	mov	dpl, #0x00
                                   3113 ;	main.h:147: }
      000C0A 22               [24] 3114 	ret
                                   3115 ;------------------------------------------------------------
                                   3116 ;Allocation info for local variables in function 'DEV_CTL'
                                   3117 ;------------------------------------------------------------
                                   3118 ;STATE         Allocated with name '_DEV_CTL_PARM_2'
                                   3119 ;DEV           Allocated to registers r7 
                                   3120 ;------------------------------------------------------------
                                   3121 ;	main.h:149: void DEV_CTL(uint8 DEV, uint8 STATE){
                                   3122 ;	-----------------------------------------
                                   3123 ;	 function DEV_CTL
                                   3124 ;	-----------------------------------------
      000C0B                       3125 _DEV_CTL:
      000C0B AF 82            [24] 3126 	mov	r7, dpl
                                   3127 ;	main.h:150: switch (DEV) {
      000C0D BF 00 02         [24] 3128 	cjne	r7,#0x00,00125$
      000C10 80 0A            [24] 3129 	sjmp	00101$
      000C12                       3130 00125$:
      000C12 BF 01 02         [24] 3131 	cjne	r7,#0x01,00126$
      000C15 80 0C            [24] 3132 	sjmp	00102$
      000C17                       3133 00126$:
                                   3134 ;	main.h:151: case 0: DEV0 = (STATE)?(HIGH):(LOW); break;
      000C17 BF 02 16         [24] 3135 	cjne	r7,#0x02,00105$
      000C1A 80 0E            [24] 3136 	sjmp	00103$
      000C1C                       3137 00101$:
                                   3138 ;	assignBit
      000C1C E5*00            [12] 3139 	mov	a,_DEV_CTL_PARM_2
      000C1E 24 FF            [12] 3140 	add	a,#0xff
      000C20 92 05            [24] 3141 	mov	_DEV0,c
                                   3142 ;	main.h:152: case 1: DEV1 = (STATE)?(HIGH):(LOW); break;
      000C22 22               [24] 3143 	ret
      000C23                       3144 00102$:
                                   3145 ;	assignBit
      000C23 E5*00            [12] 3146 	mov	a,_DEV_CTL_PARM_2
      000C25 24 FF            [12] 3147 	add	a,#0xff
      000C27 92 06            [24] 3148 	mov	_DEV1,c
                                   3149 ;	main.h:153: case 2: DEV2 = (STATE)?(HIGH):(LOW); break;
      000C29 22               [24] 3150 	ret
      000C2A                       3151 00103$:
                                   3152 ;	assignBit
      000C2A E5*00            [12] 3153 	mov	a,_DEV_CTL_PARM_2
      000C2C 24 FF            [12] 3154 	add	a,#0xff
      000C2E 92 07            [24] 3155 	mov	_DEV2,c
                                   3156 ;	main.h:154: }
      000C30                       3157 00105$:
                                   3158 ;	main.h:155: }
      000C30 22               [24] 3159 	ret
                                   3160 ;------------------------------------------------------------
                                   3161 ;Allocation info for local variables in function 'SHOW_MODE'
                                   3162 ;------------------------------------------------------------
                                   3163 ;M             Allocated to registers r7 
                                   3164 ;------------------------------------------------------------
                                   3165 ;	main.h:157: void SHOW_MODE(uint8 M){
                                   3166 ;	-----------------------------------------
                                   3167 ;	 function SHOW_MODE
                                   3168 ;	-----------------------------------------
      000C31                       3169 _SHOW_MODE:
      000C31 AF 82            [24] 3170 	mov	r7, dpl
                                   3171 ;	main.h:158: LED[7] = 0x39; LED[5] = 0xF, LED[6] = DIGIT_CODE[M];
      000C33 75*1F 39         [24] 3172 	mov	(_LED + 0x0007),#0x39
      000C36 75*1D 0F         [24] 3173 	mov	(_LED + 0x0005),#0x0f
      000C39 EF               [12] 3174 	mov	a,r7
      000C3A 90r00r00         [24] 3175 	mov	dptr,#_DIGIT_CODE
      000C3D 93               [24] 3176 	movc	a,@a+dptr
      000C3E F5*1E            [12] 3177 	mov	(_LED + 0x0006), a
                                   3178 ;	main.h:159: Disp8leds7seg(1);
      000C40 90 00 01         [24] 3179 	mov	dptr,#0x0001
                                   3180 ;	main.h:160: }
      000C43 02r07r08         [24] 3181 	ljmp	_Disp8leds7seg
                                   3182 ;------------------------------------------------------------
                                   3183 ;Allocation info for local variables in function 'change_mode'
                                   3184 ;------------------------------------------------------------
                                   3185 ;CODE          Allocated to registers r6 r7 
                                   3186 ;STATE         Allocated with name '_change_mode_STATE_10000_115'
                                   3187 ;------------------------------------------------------------
                                   3188 ;	main.h:162: void change_mode(uint32 CODE){
                                   3189 ;	-----------------------------------------
                                   3190 ;	 function change_mode
                                   3191 ;	-----------------------------------------
      000C46                       3192 _change_mode:
      000C46 AE 82            [24] 3193 	mov	r6, dpl
      000C48 AF 83            [24] 3194 	mov	r7, dph
                                   3195 ;	main.h:163: uint8 STATE = 0;
      000C4A 75*50 00         [24] 3196 	mov	_change_mode_STATE_10000_115,#0x00
                                   3197 ;	main.h:165: switch (CODE) {
      000C4D BE FD 05         [24] 3198 	cjne	r6,#0xfd,00202$
      000C50 BF 02 02         [24] 3199 	cjne	r7,#0x02,00202$
      000C53 80 1D            [24] 3200 	sjmp	00102$
      000C55                       3201 00202$:
      000C55 BE 9D 05         [24] 3202 	cjne	r6,#0x9d,00203$
      000C58 BF 62 02         [24] 3203 	cjne	r7,#0x62,00203$
      000C5B 80 5B            [24] 3204 	sjmp	00104$
      000C5D                       3205 00203$:
      000C5D BE 5D 05         [24] 3206 	cjne	r6,#0x5d,00204$
      000C60 BF A2 02         [24] 3207 	cjne	r7,#0xa2,00204$
      000C63 80 08            [24] 3208 	sjmp	00101$
      000C65                       3209 00204$:
                                   3210 ;	main.h:166: case ON_OFF: CURRENT_MODE = REMOTE; break;
      000C65 BE 3D 6F         [24] 3211 	cjne	r6,#0x3d,00105$
      000C68 BF C2 6C         [24] 3212 	cjne	r7,#0xc2,00105$
      000C6B 80 2A            [24] 3213 	sjmp	00103$
      000C6D                       3214 00101$:
      000C6D 75*28 00         [24] 3215 	mov	_CURRENT_MODE,#0x00
                                   3216 ;	main.h:167: case PREV: CURRENT_MODE = (CURRENT_MODE-1+8)%8; break;
      000C70 80 65            [24] 3217 	sjmp	00105$
      000C72                       3218 00102$:
      000C72 AC*28            [24] 3219 	mov	r4,_CURRENT_MODE
      000C74 7D 00            [12] 3220 	mov	r5,#0x00
      000C76 74 07            [12] 3221 	mov	a,#0x07
      000C78 2C               [12] 3222 	add	a, r4
      000C79 F5 82            [12] 3223 	mov	dpl,a
      000C7B E4               [12] 3224 	clr	a
      000C7C 3D               [12] 3225 	addc	a, r5
      000C7D F5 83            [12] 3226 	mov	dph,a
      000C7F 75*00 08         [24] 3227 	mov	__modsint_PARM_2,#0x08
      000C82 8D*01            [24] 3228 	mov	(__modsint_PARM_2 + 1),r5
      000C84 C0 07            [24] 3229 	push	ar7
      000C86 C0 06            [24] 3230 	push	ar6
      000C88 12r00r00         [24] 3231 	lcall	__modsint
      000C8B AC 82            [24] 3232 	mov	r4, dpl
      000C8D AD 83            [24] 3233 	mov	r5, dph
      000C8F D0 06            [24] 3234 	pop	ar6
      000C91 D0 07            [24] 3235 	pop	ar7
      000C93 8C*28            [24] 3236 	mov	_CURRENT_MODE,r4
                                   3237 ;	main.h:168: case NEXT: CURRENT_MODE = (CURRENT_MODE+1)%8; break;
      000C95 80 40            [24] 3238 	sjmp	00105$
      000C97                       3239 00103$:
      000C97 AC*28            [24] 3240 	mov	r4,_CURRENT_MODE
      000C99 7D 00            [12] 3241 	mov	r5,#0x00
      000C9B 8C 82            [24] 3242 	mov	dpl,r4
      000C9D 8D 83            [24] 3243 	mov	dph,r5
      000C9F A3               [24] 3244 	inc	dptr
      000CA0 75*00 08         [24] 3245 	mov	__modsint_PARM_2,#0x08
      000CA3 8D*01            [24] 3246 	mov	(__modsint_PARM_2 + 1),r5
      000CA5 C0 07            [24] 3247 	push	ar7
      000CA7 C0 06            [24] 3248 	push	ar6
      000CA9 12r00r00         [24] 3249 	lcall	__modsint
      000CAC AC 82            [24] 3250 	mov	r4, dpl
      000CAE AD 83            [24] 3251 	mov	r5, dph
      000CB0 D0 06            [24] 3252 	pop	ar6
      000CB2 D0 07            [24] 3253 	pop	ar7
      000CB4 8C*28            [24] 3254 	mov	_CURRENT_MODE,r4
                                   3255 ;	main.h:169: case MODE: CURRENT_MODE = (CURRENT_MODE+1)%8; break;
      000CB6 80 1F            [24] 3256 	sjmp	00105$
      000CB8                       3257 00104$:
      000CB8 AC*28            [24] 3258 	mov	r4,_CURRENT_MODE
      000CBA 7D 00            [12] 3259 	mov	r5,#0x00
      000CBC 8C 82            [24] 3260 	mov	dpl,r4
      000CBE 8D 83            [24] 3261 	mov	dph,r5
      000CC0 A3               [24] 3262 	inc	dptr
      000CC1 75*00 08         [24] 3263 	mov	__modsint_PARM_2,#0x08
      000CC4 8D*01            [24] 3264 	mov	(__modsint_PARM_2 + 1),r5
      000CC6 C0 07            [24] 3265 	push	ar7
      000CC8 C0 06            [24] 3266 	push	ar6
      000CCA 12r00r00         [24] 3267 	lcall	__modsint
      000CCD AC 82            [24] 3268 	mov	r4, dpl
      000CCF AD 83            [24] 3269 	mov	r5, dph
      000CD1 D0 06            [24] 3270 	pop	ar6
      000CD3 D0 07            [24] 3271 	pop	ar7
      000CD5 8C*28            [24] 3272 	mov	_CURRENT_MODE,r4
                                   3273 ;	main.h:170: }
      000CD7                       3274 00105$:
                                   3275 ;	main.h:172: switch (CURRENT_MODE) {
      000CD7 E5*28            [12] 3276 	mov	a,_CURRENT_MODE
      000CD9 24 F8            [12] 3277 	add	a,#0xff - 0x07
      000CDB 50 01            [24] 3278 	jnc	00206$
      000CDD 22               [24] 3279 	ret
      000CDE                       3280 00206$:
      000CDE E5*28            [12] 3281 	mov	a,_CURRENT_MODE
      000CE0 24 0B            [12] 3282 	add	a,#(00207$-3-.)
      000CE2 83               [24] 3283 	movc	a,@a+pc
      000CE3 F5 82            [12] 3284 	mov	dpl,a
      000CE5 E5*28            [12] 3285 	mov	a,_CURRENT_MODE
      000CE7 24 0C            [12] 3286 	add	a,#(00208$-3-.)
      000CE9 83               [24] 3287 	movc	a,@a+pc
      000CEA F5 83            [12] 3288 	mov	dph,a
      000CEC E4               [12] 3289 	clr	a
      000CED 73               [24] 3290 	jmp	@a+dptr
      000CEE                       3291 00207$:
      000CEErFE                    3292 	.db	00106$
      000CEFr04                    3293 	.db	00107$
      000CF0r0A                    3294 	.db	00108$
      000CF1r39                    3295 	.db	00111$
      000CF2r68                    3296 	.db	00114$
      000CF3r97                    3297 	.db	00117$
      000CF4rC7                    3298 	.db	00120$
      000CF5rFF                    3299 	.db	00123$
      000CF6                       3300 00208$:
      000CF6s0C                    3301 	.db	00106$>>8
      000CF7s0D                    3302 	.db	00107$>>8
      000CF8s0D                    3303 	.db	00108$>>8
      000CF9s0D                    3304 	.db	00111$>>8
      000CFAs0D                    3305 	.db	00114$>>8
      000CFBs0D                    3306 	.db	00117$>>8
      000CFCs0D                    3307 	.db	00120$>>8
      000CFDs0D                    3308 	.db	00123$>>8
                                   3309 ;	main.h:173: case REMOTE:
      000CFE                       3310 00106$:
                                   3311 ;	main.h:174: SHOW_MODE(1);
      000CFE 75 82 01         [24] 3312 	mov	dpl, #0x01
                                   3313 ;	main.h:175: return;
      000D01 02r0Cr31         [24] 3314 	ljmp	_SHOW_MODE
                                   3315 ;	main.h:177: case SET_DEV_ENABLE:
      000D04                       3316 00107$:
                                   3317 ;	main.h:178: SHOW_MODE(2);
      000D04 75 82 02         [24] 3318 	mov	dpl, #0x02
                                   3319 ;	main.h:179: return;
      000D07 02r0Cr31         [24] 3320 	ljmp	_SHOW_MODE
                                   3321 ;	main.h:181: case DEV_0_CTL:
      000D0A                       3322 00108$:
                                   3323 ;	main.h:182: SHOW_MODE(3);
      000D0A 75 82 03         [24] 3324 	mov	dpl, #0x03
      000D0D C0 07            [24] 3325 	push	ar7
      000D0F C0 06            [24] 3326 	push	ar6
      000D11 12r0Cr31         [24] 3327 	lcall	_SHOW_MODE
      000D14 D0 06            [24] 3328 	pop	ar6
      000D16 D0 07            [24] 3329 	pop	ar7
                                   3330 ;	main.h:183: if(CODE == PLAY_PAUSE){
      000D18 BE DD 18         [24] 3331 	cjne	r6,#0xdd,00110$
      000D1B BF 22 15         [24] 3332 	cjne	r7,#0x22,00110$
                                   3333 ;	main.h:184: SET_ON_OFF(&STATE, 0x0);
      000D1E 75*4A 00         [24] 3334 	mov	_SET_ON_OFF_PARM_2,#0x00
      000D21 90r00r50         [24] 3335 	mov	dptr,#_change_mode_STATE_10000_115
      000D24 75 F0 40         [24] 3336 	mov	b, #0x40
      000D27 12r0Br13         [24] 3337 	lcall	_SET_ON_OFF
                                   3338 ;	main.h:185: DEV_CTL(0x0, STATE);
      000D2A 85*50*00         [24] 3339 	mov	_DEV_CTL_PARM_2,_change_mode_STATE_10000_115
      000D2D 75 82 00         [24] 3340 	mov	dpl, #0x00
      000D30 12r0Cr0B         [24] 3341 	lcall	_DEV_CTL
      000D33                       3342 00110$:
                                   3343 ;	main.h:187: SHOW_MODE(3);
      000D33 75 82 03         [24] 3344 	mov	dpl, #0x03
                                   3345 ;	main.h:188: return;
      000D36 02r0Cr31         [24] 3346 	ljmp	_SHOW_MODE
                                   3347 ;	main.h:190: case DEV_1_CTL:
      000D39                       3348 00111$:
                                   3349 ;	main.h:191: SHOW_MODE(4);
      000D39 75 82 04         [24] 3350 	mov	dpl, #0x04
      000D3C C0 07            [24] 3351 	push	ar7
      000D3E C0 06            [24] 3352 	push	ar6
      000D40 12r0Cr31         [24] 3353 	lcall	_SHOW_MODE
      000D43 D0 06            [24] 3354 	pop	ar6
      000D45 D0 07            [24] 3355 	pop	ar7
                                   3356 ;	main.h:192: if(CODE == PLAY_PAUSE){
      000D47 BE DD 18         [24] 3357 	cjne	r6,#0xdd,00113$
      000D4A BF 22 15         [24] 3358 	cjne	r7,#0x22,00113$
                                   3359 ;	main.h:193: SET_ON_OFF(&STATE, 0x1);
      000D4D 75*4A 01         [24] 3360 	mov	_SET_ON_OFF_PARM_2,#0x01
      000D50 90r00r50         [24] 3361 	mov	dptr,#_change_mode_STATE_10000_115
      000D53 75 F0 40         [24] 3362 	mov	b, #0x40
      000D56 12r0Br13         [24] 3363 	lcall	_SET_ON_OFF
                                   3364 ;	main.h:194: DEV_CTL(0x1, STATE);
      000D59 85*50*00         [24] 3365 	mov	_DEV_CTL_PARM_2,_change_mode_STATE_10000_115
      000D5C 75 82 01         [24] 3366 	mov	dpl, #0x01
      000D5F 12r0Cr0B         [24] 3367 	lcall	_DEV_CTL
      000D62                       3368 00113$:
                                   3369 ;	main.h:196: SHOW_MODE(4);
      000D62 75 82 04         [24] 3370 	mov	dpl, #0x04
                                   3371 ;	main.h:197: return;
      000D65 02r0Cr31         [24] 3372 	ljmp	_SHOW_MODE
                                   3373 ;	main.h:199: case DEV_2_CTL:
      000D68                       3374 00114$:
                                   3375 ;	main.h:200: SHOW_MODE(5);
      000D68 75 82 05         [24] 3376 	mov	dpl, #0x05
      000D6B C0 07            [24] 3377 	push	ar7
      000D6D C0 06            [24] 3378 	push	ar6
      000D6F 12r0Cr31         [24] 3379 	lcall	_SHOW_MODE
      000D72 D0 06            [24] 3380 	pop	ar6
      000D74 D0 07            [24] 3381 	pop	ar7
                                   3382 ;	main.h:201: if(CODE == PLAY_PAUSE){
      000D76 BE DD 18         [24] 3383 	cjne	r6,#0xdd,00116$
      000D79 BF 22 15         [24] 3384 	cjne	r7,#0x22,00116$
                                   3385 ;	main.h:202: SET_ON_OFF(&STATE, 0x2);
      000D7C 75*4A 02         [24] 3386 	mov	_SET_ON_OFF_PARM_2,#0x02
      000D7F 90r00r50         [24] 3387 	mov	dptr,#_change_mode_STATE_10000_115
      000D82 75 F0 40         [24] 3388 	mov	b, #0x40
      000D85 12r0Br13         [24] 3389 	lcall	_SET_ON_OFF
                                   3390 ;	main.h:203: DEV_CTL(0x2, STATE);
      000D88 85*50*00         [24] 3391 	mov	_DEV_CTL_PARM_2,_change_mode_STATE_10000_115
      000D8B 75 82 02         [24] 3392 	mov	dpl, #0x02
      000D8E 12r0Cr0B         [24] 3393 	lcall	_DEV_CTL
      000D91                       3394 00116$:
                                   3395 ;	main.h:205: SHOW_MODE(5);
      000D91 75 82 05         [24] 3396 	mov	dpl, #0x05
                                   3397 ;	main.h:206: return;
      000D94 02r0Cr31         [24] 3398 	ljmp	_SHOW_MODE
                                   3399 ;	main.h:208: case DEV_2_SET_ON_TIMER:
      000D97                       3400 00117$:
                                   3401 ;	main.h:209: SHOW_MODE(6);
      000D97 75 82 06         [24] 3402 	mov	dpl, #0x06
      000D9A C0 07            [24] 3403 	push	ar7
      000D9C C0 06            [24] 3404 	push	ar6
      000D9E 12r0Cr31         [24] 3405 	lcall	_SHOW_MODE
      000DA1 D0 06            [24] 3406 	pop	ar6
      000DA3 D0 07            [24] 3407 	pop	ar7
                                   3408 ;	main.h:210: if(CODE == PLAY_PAUSE) {
      000DA5 BE DD 19         [24] 3409 	cjne	r6,#0xdd,00119$
      000DA8 BF 22 16         [24] 3410 	cjne	r7,#0x22,00119$
                                   3411 ;	main.h:211: LED[7] = DIGIT_CODE[0]; LED[6] = 0x37;
      000DAB 90r00r00         [24] 3412 	mov	dptr,#_DIGIT_CODE
      000DAE E4               [12] 3413 	clr	a
      000DAF 93               [24] 3414 	movc	a,@a+dptr
      000DB0 F5*1F            [12] 3415 	mov	(_LED + 0x0007), a
      000DB2 75*1E 37         [24] 3416 	mov	(_LED + 0x0006),#0x37
                                   3417 ;	main.h:212: LED[5] = 0x0;
      000DB5 75*1D 00         [24] 3418 	mov	(_LED + 0x0005),#0x00
                                   3419 ;	main.h:213: SET_TIMER(&time_on);
      000DB8 90r00r32         [24] 3420 	mov	dptr,#_time_on
      000DBB 75 F0 40         [24] 3421 	mov	b, #0x40
      000DBE 12r09rC3         [24] 3422 	lcall	_SET_TIMER
      000DC1                       3423 00119$:
                                   3424 ;	main.h:215: SHOW_MODE(6);
      000DC1 75 82 06         [24] 3425 	mov	dpl, #0x06
                                   3426 ;	main.h:216: return;
      000DC4 02r0Cr31         [24] 3427 	ljmp	_SHOW_MODE
                                   3428 ;	main.h:218: case DEV_2_SET_OFF_TIMER:
      000DC7                       3429 00120$:
                                   3430 ;	main.h:219: SHOW_MODE(7);
      000DC7 75 82 07         [24] 3431 	mov	dpl, #0x07
      000DCA C0 07            [24] 3432 	push	ar7
      000DCC C0 06            [24] 3433 	push	ar6
      000DCE 12r0Cr31         [24] 3434 	lcall	_SHOW_MODE
      000DD1 D0 06            [24] 3435 	pop	ar6
      000DD3 D0 07            [24] 3436 	pop	ar7
                                   3437 ;	main.h:220: if(CODE == PLAY_PAUSE){
      000DD5 BE DD 21         [24] 3438 	cjne	r6,#0xdd,00122$
      000DD8 BF 22 1E         [24] 3439 	cjne	r7,#0x22,00122$
                                   3440 ;	main.h:221: SET_TIMER(&time_off);
      000DDB 90r00r39         [24] 3441 	mov	dptr,#_time_off
      000DDE 75 F0 40         [24] 3442 	mov	b, #0x40
      000DE1 12r09rC3         [24] 3443 	lcall	_SET_TIMER
                                   3444 ;	main.h:222: LED[7] = DIGIT_CODE[0]; LED[6] = DIGIT_CODE[15]; 
      000DE4 90r00r00         [24] 3445 	mov	dptr,#_DIGIT_CODE
      000DE7 E4               [12] 3446 	clr	a
      000DE8 93               [24] 3447 	movc	a,@a+dptr
      000DE9 F5*1F            [12] 3448 	mov	(_LED + 0x0007), a
      000DEB 90r00r0F         [24] 3449 	mov	dptr,#(_DIGIT_CODE + 0x000f)
      000DEE E4               [12] 3450 	clr	a
      000DEF 93               [24] 3451 	movc	a,@a+dptr
      000DF0 F5*1E            [12] 3452 	mov	(_LED + 0x0006), a
                                   3453 ;	main.h:223: LED[5] = DIGIT_CODE[15];
      000DF2 90r00r0F         [24] 3454 	mov	dptr,#(_DIGIT_CODE + 0x000f)
      000DF5 E4               [12] 3455 	clr	a
      000DF6 93               [24] 3456 	movc	a,@a+dptr
      000DF7 F5*1D            [12] 3457 	mov	(_LED + 0x0005), a
      000DF9                       3458 00122$:
                                   3459 ;	main.h:225: SHOW_MODE(7);
      000DF9 75 82 07         [24] 3460 	mov	dpl, #0x07
                                   3461 ;	main.h:226: return;
                                   3462 ;	main.h:228: case SETUP_SYS_TIME:
      000DFC 02r0Cr31         [24] 3463 	ljmp	_SHOW_MODE
      000DFF                       3464 00123$:
                                   3465 ;	main.h:229: SHOW_MODE(8);
      000DFF 75 82 08         [24] 3466 	mov	dpl, #0x08
      000E02 C0 07            [24] 3467 	push	ar7
      000E04 C0 06            [24] 3468 	push	ar6
      000E06 12r0Cr31         [24] 3469 	lcall	_SHOW_MODE
      000E09 D0 06            [24] 3470 	pop	ar6
      000E0B D0 07            [24] 3471 	pop	ar7
                                   3472 ;	main.h:230: if( CODE == PLAY_PAUSE && SET_TIMER(&sys_time) ){
      000E0D BE DD 2D         [24] 3473 	cjne	r6,#0xdd,00125$
      000E10 BF 22 2A         [24] 3474 	cjne	r7,#0x22,00125$
      000E13 90r00r2B         [24] 3475 	mov	dptr,#_sys_time
      000E16 75 F0 40         [24] 3476 	mov	b, #0x40
      000E19 12r09rC3         [24] 3477 	lcall	_SET_TIMER
      000E1C E5 82            [12] 3478 	mov	a, dpl
      000E1E 60 1D            [24] 3479 	jz	00125$
                                   3480 ;	main.h:231: LED[7] = DIGIT_CODE[5]; LED[6] = 0x72; LED[5] = DIGIT_CODE[5];
      000E20 90r00r05         [24] 3481 	mov	dptr,#(_DIGIT_CODE + 0x0005)
      000E23 E4               [12] 3482 	clr	a
      000E24 93               [24] 3483 	movc	a,@a+dptr
      000E25 F5*1F            [12] 3484 	mov	(_LED + 0x0007), a
      000E27 75*1E 72         [24] 3485 	mov	(_LED + 0x0006),#0x72
      000E2A 90r00r05         [24] 3486 	mov	dptr,#(_DIGIT_CODE + 0x0005)
      000E2D E4               [12] 3487 	clr	a
      000E2E 93               [24] 3488 	movc	a,@a+dptr
      000E2F F5*1D            [12] 3489 	mov	(_LED + 0x0005), a
                                   3490 ;	main.h:232: ds1302_write_time(&sys_time, 0x3F);
      000E31 75*17 3F         [24] 3491 	mov	_ds1302_write_time_PARM_2,#0x3f
      000E34 90r00r2B         [24] 3492 	mov	dptr,#_sys_time
      000E37 75 F0 40         [24] 3493 	mov	b, #0x40
      000E3A 12r04r64         [24] 3494 	lcall	_ds1302_write_time
      000E3D                       3495 00125$:
                                   3496 ;	main.h:234: SHOW_MODE(8);
      000E3D 75 82 08         [24] 3497 	mov	dpl, #0x08
                                   3498 ;	main.h:235: return;
                                   3499 ;	main.h:236: }
                                   3500 ;	main.h:237: }
      000E40 02r0Cr31         [24] 3501 	ljmp	_SHOW_MODE
                                   3502 ;------------------------------------------------------------
                                   3503 ;Allocation info for local variables in function 'sys_time_disp'
                                   3504 ;------------------------------------------------------------
                                   3505 ;mili_sec      Allocated to registers r6 r7 
                                   3506 ;------------------------------------------------------------
                                   3507 ;	main.h:239: void sys_time_disp(uint32 mili_sec){
                                   3508 ;	-----------------------------------------
                                   3509 ;	 function sys_time_disp
                                   3510 ;	-----------------------------------------
      000E43                       3511 _sys_time_disp:
      000E43 AE 82            [24] 3512 	mov	r6, dpl
      000E45 AF 83            [24] 3513 	mov	r7, dph
                                   3514 ;	main.h:240: LED[3] = DIGIT_CODE[sys_time.HOUR/10];
      000E47 AD*2F            [24] 3515 	mov	r5,(_sys_time + 0x0004)
      000E49 75 F0 0A         [24] 3516 	mov	b,#0x0a
      000E4C ED               [12] 3517 	mov	a,r5
      000E4D 84               [48] 3518 	div	ab
      000E4E 7C 00            [12] 3519 	mov	r4,#0x00
      000E50 90r00r00         [24] 3520 	mov	dptr,#_DIGIT_CODE
      000E53 93               [24] 3521 	movc	a,@a+dptr
      000E54 F5*1B            [12] 3522 	mov	(_LED + 0x0003), a
                                   3523 ;	main.h:241: LED[2] = DIGIT_CODE[sys_time.HOUR%10];
      000E56 AD*2F            [24] 3524 	mov	r5,(_sys_time + 0x0004)
      000E58 75 F0 0A         [24] 3525 	mov	b,#0x0a
      000E5B ED               [12] 3526 	mov	a,r5
      000E5C 84               [48] 3527 	div	ab
      000E5D E5 F0            [12] 3528 	mov	a,b
      000E5F 24r00            [12] 3529 	add	a, #_DIGIT_CODE
      000E61 F5 82            [12] 3530 	mov	dpl,a
      000E63 EC               [12] 3531 	mov	a,r4
      000E64 34s00            [12] 3532 	addc	a, #(_DIGIT_CODE >> 8)
      000E66 F5 83            [12] 3533 	mov	dph,a
      000E68 E4               [12] 3534 	clr	a
      000E69 93               [24] 3535 	movc	a,@a+dptr
      000E6A F5*1A            [12] 3536 	mov	(_LED + 0x0002), a
                                   3537 ;	main.h:242: LED[1] = DIGIT_CODE[sys_time.MINUTE/10];
      000E6C AD*30            [24] 3538 	mov	r5,(_sys_time + 0x0005)
      000E6E 75 F0 0A         [24] 3539 	mov	b,#0x0a
      000E71 ED               [12] 3540 	mov	a,r5
      000E72 84               [48] 3541 	div	ab
      000E73 24r00            [12] 3542 	add	a, #_DIGIT_CODE
      000E75 F5 82            [12] 3543 	mov	dpl,a
      000E77 EC               [12] 3544 	mov	a,r4
      000E78 34s00            [12] 3545 	addc	a, #(_DIGIT_CODE >> 8)
      000E7A F5 83            [12] 3546 	mov	dph,a
      000E7C E4               [12] 3547 	clr	a
      000E7D 93               [24] 3548 	movc	a,@a+dptr
      000E7E F5*19            [12] 3549 	mov	(_LED + 0x0001), a
                                   3550 ;	main.h:243: LED[0] = DIGIT_CODE[sys_time.MINUTE%10];
      000E80 AD*30            [24] 3551 	mov	r5,(_sys_time + 0x0005)
      000E82 75 F0 0A         [24] 3552 	mov	b,#0x0a
      000E85 ED               [12] 3553 	mov	a,r5
      000E86 84               [48] 3554 	div	ab
      000E87 E5 F0            [12] 3555 	mov	a,b
      000E89 24r00            [12] 3556 	add	a, #_DIGIT_CODE
      000E8B F5 82            [12] 3557 	mov	dpl,a
      000E8D EC               [12] 3558 	mov	a,r4
      000E8E 34s00            [12] 3559 	addc	a, #(_DIGIT_CODE >> 8)
      000E90 F5 83            [12] 3560 	mov	dph,a
      000E92 E4               [12] 3561 	clr	a
      000E93 93               [24] 3562 	movc	a,@a+dptr
      000E94 F5*18            [12] 3563 	mov	_LED, a
                                   3564 ;	main.h:244: Disp8leds7seg(mili_sec);
      000E96 8E 82            [24] 3565 	mov	dpl, r6
      000E98 8F 83            [24] 3566 	mov	dph, r7
                                   3567 ;	main.h:245: }
      000E9A 02r07r08         [24] 3568 	ljmp	_Disp8leds7seg
                                   3569 ;------------------------------------------------------------
                                   3570 ;Allocation info for local variables in function 'main_intial'
                                   3571 ;------------------------------------------------------------
                                   3572 ;	main.h:247: void main_intial(){
                                   3573 ;	-----------------------------------------
                                   3574 ;	 function main_intial
                                   3575 ;	-----------------------------------------
      000E9D                       3576 _main_intial:
                                   3577 ;	main.h:248: ds1302_initial();
      000E9D 12r06r87         [24] 3578 	lcall	_ds1302_initial
                                   3579 ;	main.h:249: IR_Reading_Initial();
      000EA0 12r08r48         [24] 3580 	lcall	_IR_Reading_Initial
                                   3581 ;	main.h:250: LED_7SEG = 0x0;
      000EA3 75 80 00         [24] 3582 	mov	_P0,#0x00
                                   3583 ;	main.h:251: sys_time.HOUR = 0;
      000EA6 75*2F 00         [24] 3584 	mov	(_sys_time + 0x0004),#0x00
                                   3585 ;	main.h:252: sys_time.MINUTE = 0;
      000EA9 75*30 00         [24] 3586 	mov	(_sys_time + 0x0005),#0x00
                                   3587 ;	main.h:253: sys_time.SECOND = 0;
      000EAC 75*31 00         [24] 3588 	mov	(_sys_time + 0x0006),#0x00
                                   3589 ;	main.h:254: sys_time.DATE = 0;
      000EAF 75*2C 00         [24] 3590 	mov	(_sys_time + 0x0001),#0x00
                                   3591 ;	main.h:255: sys_time.DAY = 0;
      000EB2 75*2B 00         [24] 3592 	mov	_sys_time,#0x00
                                   3593 ;	main.h:256: sys_time.MONTH = 0;
      000EB5 75*2D 00         [24] 3594 	mov	(_sys_time + 0x0002),#0x00
                                   3595 ;	main.h:257: sys_time.YEAR = 0;
      000EB8 75*2E 00         [24] 3596 	mov	(_sys_time + 0x0003),#0x00
                                   3597 ;	main.h:258: ds1302_write_time(&sys_time, 0x7F);
      000EBB 75*17 7F         [24] 3598 	mov	_ds1302_write_time_PARM_2,#0x7f
      000EBE 90r00r2B         [24] 3599 	mov	dptr,#_sys_time
      000EC1 75 F0 40         [24] 3600 	mov	b, #0x40
                                   3601 ;	main.h:259: }
      000EC4 02r04r64         [24] 3602 	ljmp	_ds1302_write_time
                                   3603 ;------------------------------------------------------------
                                   3604 ;Allocation info for local variables in function 'main'
                                   3605 ;------------------------------------------------------------
                                   3606 ;C             Allocated to registers r6 r7 
                                   3607 ;------------------------------------------------------------
                                   3608 ;	main.c:3: int main(){
                                   3609 ;	-----------------------------------------
                                   3610 ;	 function main
                                   3611 ;	-----------------------------------------
      000EC7                       3612 _main:
                                   3613 ;	main.c:4: main_intial();
      000EC7 12r0Er9D         [24] 3614 	lcall	_main_intial
                                   3615 ;	main.c:5: change_mode(REMOTE);
      000ECA 90 00 00         [24] 3616 	mov	dptr,#0x0000
      000ECD 12r0Cr46         [24] 3617 	lcall	_change_mode
                                   3618 ;	main.c:7: while(0x1){
      000ED0                       3619 00102$:
                                   3620 ;	main.c:8: ds1302_read_time(&sys_time, 0x7);
      000ED0 75*12 07         [24] 3621 	mov	_ds1302_read_time_PARM_2,#0x07
      000ED3 90r00r2B         [24] 3622 	mov	dptr,#_sys_time
      000ED6 75 F0 40         [24] 3623 	mov	b, #0x40
      000ED9 12r02r1D         [24] 3624 	lcall	_ds1302_read_time
                                   3625 ;	main.c:12: C = read_extracted_frame();
      000EDC 12r08r3C         [24] 3626 	lcall	_read_extracted_frame
      000EDF AE 82            [24] 3627 	mov	r6, dpl
      000EE1 AF 83            [24] 3628 	mov	r7, dph
                                   3629 ;	main.c:13: LED[7]= DIGIT_CODE[ (C) & 0xF];
      000EE3 74 0F            [12] 3630 	mov	a,#0x0f
      000EE5 5E               [12] 3631 	anl	a,r6
      000EE6 90r00r00         [24] 3632 	mov	dptr,#_DIGIT_CODE
      000EE9 93               [24] 3633 	movc	a,@a+dptr
      000EEA F5*1F            [12] 3634 	mov	(_LED + 0x0007), a
                                   3635 ;	main.c:14: LED[6]= DIGIT_CODE[ (C>>4) & 0xF];
      000EEC 8E 04            [24] 3636 	mov	ar4,r6
      000EEE EF               [12] 3637 	mov	a,r7
      000EEF C4               [12] 3638 	swap	a
      000EF0 CC               [12] 3639 	xch	a,r4
      000EF1 C4               [12] 3640 	swap	a
      000EF2 54 0F            [12] 3641 	anl	a,#0x0f
      000EF4 6C               [12] 3642 	xrl	a,r4
      000EF5 CC               [12] 3643 	xch	a,r4
      000EF6 54 0F            [12] 3644 	anl	a,#0x0f
      000EF8 CC               [12] 3645 	xch	a,r4
      000EF9 6C               [12] 3646 	xrl	a,r4
      000EFA CC               [12] 3647 	xch	a,r4
      000EFB 53 04 0F         [24] 3648 	anl	ar4,#0x0f
      000EFE 7D 00            [12] 3649 	mov	r5,#0x00
      000F00 EC               [12] 3650 	mov	a,r4
      000F01 24r00            [12] 3651 	add	a, #_DIGIT_CODE
      000F03 F5 82            [12] 3652 	mov	dpl,a
      000F05 ED               [12] 3653 	mov	a,r5
      000F06 34s00            [12] 3654 	addc	a, #(_DIGIT_CODE >> 8)
      000F08 F5 83            [12] 3655 	mov	dph,a
      000F0A E4               [12] 3656 	clr	a
      000F0B 93               [24] 3657 	movc	a,@a+dptr
      000F0C F5*1E            [12] 3658 	mov	(_LED + 0x0006), a
                                   3659 ;	main.c:15: LED[5]= DIGIT_CODE[ (C>>8) & 0xF];
      000F0E 8F 05            [24] 3660 	mov	ar5,r7
      000F10 53 05 0F         [24] 3661 	anl	ar5,#0x0f
      000F13 7C 00            [12] 3662 	mov	r4,#0x00
      000F15 ED               [12] 3663 	mov	a,r5
      000F16 24r00            [12] 3664 	add	a, #_DIGIT_CODE
      000F18 F5 82            [12] 3665 	mov	dpl,a
      000F1A EC               [12] 3666 	mov	a,r4
      000F1B 34s00            [12] 3667 	addc	a, #(_DIGIT_CODE >> 8)
      000F1D F5 83            [12] 3668 	mov	dph,a
      000F1F E4               [12] 3669 	clr	a
      000F20 93               [24] 3670 	movc	a,@a+dptr
      000F21 F5*1D            [12] 3671 	mov	(_LED + 0x0005), a
                                   3672 ;	main.c:16: LED[4]= DIGIT_CODE[ (C>>12) & 0xF];
      000F23 EF               [12] 3673 	mov	a,r7
      000F24 C4               [12] 3674 	swap	a
      000F25 54 0F            [12] 3675 	anl	a,#0x0f
      000F27 FE               [12] 3676 	mov	r6,a
      000F28 53 06 0F         [24] 3677 	anl	ar6,#0x0f
      000F2B 7F 00            [12] 3678 	mov	r7,#0x00
      000F2D EE               [12] 3679 	mov	a,r6
      000F2E 24r00            [12] 3680 	add	a, #_DIGIT_CODE
      000F30 F5 82            [12] 3681 	mov	dpl,a
      000F32 EF               [12] 3682 	mov	a,r7
      000F33 34s00            [12] 3683 	addc	a, #(_DIGIT_CODE >> 8)
      000F35 F5 83            [12] 3684 	mov	dph,a
      000F37 E4               [12] 3685 	clr	a
      000F38 93               [24] 3686 	movc	a,@a+dptr
      000F39 F5*1C            [12] 3687 	mov	(_LED + 0x0004), a
                                   3688 ;	main.c:17: LED[3]= DIGIT_CODE[ (C>>16) & 0xF];
      000F3B 90r00r00         [24] 3689 	mov	dptr,#_DIGIT_CODE
      000F3E E4               [12] 3690 	clr	a
      000F3F 93               [24] 3691 	movc	a,@a+dptr
      000F40 F5*1B            [12] 3692 	mov	(_LED + 0x0003), a
                                   3693 ;	main.c:18: LED[2]= DIGIT_CODE[ (C>>20) & 0xF];
      000F42 90r00r00         [24] 3694 	mov	dptr,#_DIGIT_CODE
      000F45 E4               [12] 3695 	clr	a
      000F46 93               [24] 3696 	movc	a,@a+dptr
      000F47 F5*1A            [12] 3697 	mov	(_LED + 0x0002), a
                                   3698 ;	main.c:19: LED[1]= DIGIT_CODE[ (C>>24) & 0xF];
      000F49 90r00r00         [24] 3699 	mov	dptr,#_DIGIT_CODE
      000F4C E4               [12] 3700 	clr	a
      000F4D 93               [24] 3701 	movc	a,@a+dptr
      000F4E F5*19            [12] 3702 	mov	(_LED + 0x0001), a
                                   3703 ;	main.c:20: LED[0]= DIGIT_CODE[ (C>>28) & 0xF];
      000F50 90r00r00         [24] 3704 	mov	dptr,#_DIGIT_CODE
      000F53 E4               [12] 3705 	clr	a
      000F54 93               [24] 3706 	movc	a,@a+dptr
      000F55 F5*18            [12] 3707 	mov	_LED, a
                                   3708 ;	main.c:21: Disp8leds7seg(1000);
      000F57 90 03 E8         [24] 3709 	mov	dptr,#0x03e8
      000F5A 12r07r08         [24] 3710 	lcall	_Disp8leds7seg
                                   3711 ;	main.c:24: return 0;
                                   3712 ;	main.c:25: }
      000F5D 02r0ErD0         [24] 3713 	ljmp	00102$
                                   3714 	.area CSEG    (CODE)
                                   3715 	.area CONST   (CODE)
                                   3716 	.area CONST   (CODE)
      000000                       3717 _DIGIT_CODE:
      000000 3F                    3718 	.db #0x3f	; 63
      000001 06                    3719 	.db #0x06	; 6
      000002 5B                    3720 	.db #0x5b	; 91
      000003 4F                    3721 	.db #0x4f	; 79	'O'
      000004 66                    3722 	.db #0x66	; 102	'f'
      000005 6D                    3723 	.db #0x6d	; 109	'm'
      000006 7D                    3724 	.db #0x7d	; 125
      000007 07                    3725 	.db #0x07	; 7
      000008 7F                    3726 	.db #0x7f	; 127
      000009 6F                    3727 	.db #0x6f	; 111	'o'
      00000A 77                    3728 	.db #0x77	; 119	'w'
      00000B 7C                    3729 	.db #0x7c	; 124
      00000C 58                    3730 	.db #0x58	; 88	'X'
      00000D 5E                    3731 	.db #0x5e	; 94
      00000E 79                    3732 	.db #0x79	; 121	'y'
      00000F 71                    3733 	.db #0x71	; 113	'q'
                                   3734 	.area CSEG    (CODE)
                                   3735 	.area XINIT   (CODE)
                                   3736 	.area CABS    (ABS,CODE)
